{
  "data": {
    "prompts": [
      {
        "question": "create building agents from the buildings_simple.shp file located in the includes folder, and initialize the agents' height and type attributes respectively from the \"HEIGHT\" and \"NATURE\" attributes in the Shapefile.",
        "answer": "create building from: shape_file(\"../includes/buildings_simple.shp\") with:(height:float(get(\"HEIGHT\")), type:string(get(\"NATURE\")));",
        "nickname": "patrick"
      },
      {
        "question": "Create a model with one experiment called GIS_agentification to import the geometries in the buildings_simple.shp shapefile in the includes folder and agentify them as building agents, that are displayed in gray in the display city_display.",
        "answer": "model simpleShapefileLoading\n\n\nglobal {\n    file shape_file_buildings <- shape_file(\\\"../includes/buildings_simple.shp\\\");\n    \n    geometry shape <- envelope(shape_file_buildings);\n    init {\n        create building from: shape_file_buildings;\n    }\n}\n\nspecies building {\n\n    aspect default {\n        draw shape color: #gray;\n    }\n    \n}\n\nexperiment GIS_agentification type: gui {\n    output {\n        display city_display {\n            species building;\n        }\n    }\n}",
        "nickname": "patrick"
      },
      {
        "question": "define a default aspect that draws the agent as a circle with a radius of 0.5 m, red in color and with a yellow border.",
        "answer": "aspect default {\n    draw circle(0.5) color: #red border: #yellow;\n}",
        "nickname": "patrick"
      },
      {
        "question": "Given a list l and a value v, how can I see if the list l contains the value v ?",
        "answer": "bool l_contain_v <- l contains v;",
        "nickname": "patrick"
      },
      {
        "question": "I want my road agents to be displayed with their geometries in red by default, with a width of 5m. ",
        "answer": "species road {\n\taspect default {\n\t\tdraw shape + 5.0 color: #red;\n\t}\n}\n ",
        "nickname": "Patrick"
      },
      {
        "question": "writes a model in which 'people' agents move on a 50 by 50 'cell' grid, avoiding obstacles. Each grid cell has a probability of 0.2 of being an obstacle (drawn in black - white if not). There is a 'goal' agent represented by a red circle of 0.5m radius placed at initialization on a random cell that is not an obstacle. There are 10 'people' agents, also placed at initialization on non-obstacle cell and represented by 0.5m-radius green circles. Until they arrive, people agents move at each simulation step at a speed of 3m/s towards the goal agent, avoiding the obstacle cells.",
        "answer": "model Grid\n\nglobal {\n\tinit {    \n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell width: 50 height: 50  {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- float(3);\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t}\n\t\n\treflex move when: location != target{\n\t\tdo goto (on:(cell where not each.is_obstacle), target:target, speed:speed);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal  ;\n\t\t\tspecies people ;\n\t\t}\n\t}\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "writes a model in which 'people' agents move along a set of roads to reach a target. At initialization, a network of roads is created from the \"roads.shp\" shapefile in the \"includes\" folder.  These roads are used to build a graph called \"the_graph\". Once the graph has been calculated, 1 \"goal\" agent and 100 \"people\" agents are created, each randomly placed on one of the roads.  At each time step, the people agents move directly from the goal agent using the roads at a speed of 1m/s. In the display, the roads are represented by their geometry drawn in black, the goal agent by a red circle with a radius of 50m and the people agents by a green circle with a radius of 50m. ",
        "answer": "model Network\n\nglobal {\n\tfile shape_file_in <- file('../includes/roads.shp') ;\n\tgraph the_graph; \n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tint nb_people <- 100;\n\t\n\tinit {    \n\t\tcreate road from: shape_file_in ;\n\t\tthe_graph <- as_edge_graph(list(road));\n\t\n\t\tcreate goal {\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t}\n\t\tcreate people number: nb_people {\n\t\t\ttarget <- one_of (goal) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t} \n\t}\n}\n\nspecies road  {\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n} \n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(50) color: #red;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\taspect default {\n\t\tdraw circle(50) color: #green;\n\t}\n\treflex movement {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n}\n\n\nexperiment goto_network type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies road ;\n\t\t\tspecies people  ;\n\t\t\tspecies goal  ;\n\t\t}\n\t}\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Define a species of agents called \"thread_agent\" which executes every 1 second in a specific thread an action that writes the agent's name and the current time to the console. ",
        "answer": "species thread_agent skills: [thread] {\n\tinit {\n\t\tdo run_thread every: 1#s;\n\t}\n\t\n\t//the action run in the thread\n\taction thread_action {\n\t\twrite \" > \" + self + \"current time: \" + #now;\n\t}\t\n}",
        "nickname": "Patrick"
      },
      {
        "question": "Defines a type of agent called people which moves towards a randomly chosen point in the space it perceives at a speed of 1m/s. The space it perceives is calculated at each time step by a 60-degree amplitude perception cone at a maximum distance of 40m, masked by agents of the obstacle species with a precision of 600. People agents are drawn by default in the form of a red triangle with 2m sides, oriented in the direction in which the agent is moving. In addition, if the perception zone is not null, it is drawn in green. \n",
        "answer": "species people skills: [moving]{\n\tgeometry perceived_area;\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\ttarget <- any_location_in(perceived_area);\n\t\t} \n\t\tdo goto target: target;\n\t\tif (location = target)  {\n\t\t\ttarget <- nil;\n\t\t}\n\t}\n\t\n\treflex update_perception {\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(40.0); \n\t\t\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,600);\n\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t}\n\t}\n}",
        "nickname": "Patrick"
      },
      {
        "question": "Code a species called People with the attributes speed of type float, health of type int, and a boolean called is_happy. People can migrate if they are not happy.\n",
        "answer": "species People {\n        float speed <- 1.0f;\n        int health <- 30;\n        bool is_happy <- false;\n\n        init {\n            // Init section of species People\n        }\n\n        // Species People can migrate if not happy\n        reflex migrate when: !is_happy {\n            // Actions to perform when the reflex is triggered\n        }\n    }",
        "nickname": "Tu"
      },
      {
        "question": "Create a display to show my map gauss_distrib in a bar chart. The title should be \"Gauss Distribution\". The list of bins are accessed with the \"legend\" key, the list of values of each bin with the \"values\" key",
        "answer": "display \"Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Gauss Distribution\" type: histogram {\n\t\t\t\tdatalist (gauss_distrib at \"legend\") value: (gauss_distrib at \"values\");\n\t\t\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "How to place a camera at a specific places in my model? ",
        "answer": "display view type: opengl {\ncamera 'default' location: {x1,y1,z1} target: {x2,y2,z2};\n}",
        "nickname": "Arno"
      },
      {
        "question": "Defines a model called test_time which stores in a global map called time_action of type string float the time taken by the model's global actions, and which displays in a global reflex called display_benchmark every 100 cycles the time taken in ms by each action. In the model, a single action is defined, called \"action_loop\", which performs an empty loop of 1000 iterations.  This action is called in a reflex called dynamic at each time step. Finally, an experiment called run is defined. \n",
        "answer": "model test_time\n\nglobal {\n\tmap<string, float> time_action;\n\t\n\t\n\treflex dynamic {\n\t\tdo action_loop;\n\t}\n\t\n\treflex display_benchmark when: every(100 #cycle){\n\t\twrite \"***** \" + cycle + \" *****\";\n\t\tloop act over: time_action.keys {\n\t\t\twrite act + \" -> \" + time_action[act] + \"ms\";\n\t\t}\n\t}\n\t\n\taction action_loop {\n\t\tfloat t <- machine_time;\n\t\tloop times: 1000 {\n\t\t}\n\t\ttime_action[\"action_loop\"] <-  time_action[\"action_loop\"] + (machine_time -t);\n\t}\n}\n\nexperiment run;",
        "nickname": "Patrick"
      },
      {
        "question": "In this experiment, add an additional simulation to be run in parallel with 5 as the value for the global variable nb_agents: \n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}",
        "answer": "\nexperiment main type: gui {\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default) with the following parameters\n\t\tcreate simulation with: (nb_agents: 5);\n\t\t\n\t}\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}",
        "nickname": "Patrick"
      },
      {
        "question": "in experiment \"main\", define a minimum duration for each cycle of 0.1s",
        "answer": "\nexperiment main type: gui {\n\t//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.1;\n}",
        "nickname": "Patrick"
      },
      {
        "question": "Create 100 individual agents at the initialization of the model",
        "answer": "global {\n\ninit {\ncreate individual number:100\n}\n\n}\n\nspecies individual {}",
        "nickname": "Kevin"
      },
      {
        "question": "generates a snippet of code that asks 2 random agents of the species \"dummy_species\" to write their name on the console. ",
        "answer": "ask 2 among dummy_species {\n\twrite name;\n}",
        "nickname": "Patrick"
      },
      {
        "question": "How to create agent from a given species with initial values ?",
        "answer": "\ninit\n{\n  int value <- 10;\n  create speciesName with: [data::value];\n}\n\nspecies speciesName \n{\n   int data;\n}",
        "nickname": "Guest"
      },
      {
        "question": "define a sheep species that can wander randomly in continuous environment",
        "answer": "species sheep skills:[moving]{\nrelfex wandering{\ndo wander;\n}\n}",
        "nickname": "Patrick"
      },
      {
        "question": "Write a loop statement over a species of agent",
        "answer": "loop i over: speciesName\n{\n   write(i.data);\n}\n\n\n\nspecies speciesName\n{\n  int data <- 10 // random value\n}",
        "nickname": "Guest"
      },
      {
        "question": " model creates a simple simulation of agents moving randomly in a continuous space.\n\n",
        "answer": "model simple_agent_model\n\nglobal {\n  int nb_agents <- 100;\n  geometry shape <- square(100);\n  init {\n    create species1 number: nb_agents {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies species1 {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species species1 aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "model simulates a predator-prey relationship. predators and preys are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The predators have an additional reflex eat block, which causes any preys within a distance of 1 to die. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.\n\n",
        "answer": "model PredatorPrey\n\nglobal {\n  int nb_predators <- 50;\n  int nb_preys <- 200;\n  geometry shape <- square(100);\n  init {\n    create predators number: nb_predators {\n      location <- one_of(shape);\n    }\n    create preys number: nb_preys {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies predators {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask preys within: 1 {\n      do die;\n    }\n  }\n}\n\nspecies preys {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species predators aspect: base;\n      species preys aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Put a circle in the center of the model. Make it grow each simulation step and until it covers the whole space of the model",
        "answer": "global {\n\ngeometry circle <- circle(1) at_location {50,50};\n\nreflex grow when: circle.width < 100 {\ncircle <- circle buffer 1;\n}\n\n}",
        "nickname": "Kevin"
      },
      {
        "question": "generates a code snippet that creates road agents from the file roads_shape_file and that builds the road_network graph from these roads. ",
        "answer": "create road from: roads_shape_file;\nroad_network <- as_edge_graph(road);\n\t",
        "nickname": "Patrick"
      },
      {
        "question": "Using the network plugin, generate a reflex to display a message that have been received",
        "answer": "reflex fetch_message when:has_more_message()\n{\t\n   message mess <- fetch_message();\n   write(\"received message : \" + mess);\n}",
        "nickname": "Guest"
      },
      {
        "question": "write a model with sheep and wolves are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The wolves have an additional reflex eat block, which causes any sheep within a distance of 1 to die. The sheep have an additional reflex eaten block, which causes them to die if a wolf is within a distance of 1. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.",
        "answer": "model Ecosystem\n\nglobal {\n  int nb_sheep <- 100;\n  int nb_wolves <- 50;\n  geometry shape <- square(100);\n  init {\n    create sheep number: nb_sheep {\n      location <- one_of(shape);\n    }\n    create wolves number: nb_wolves {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies sheep {\n  aspect base {\n    draw circle(1) color: #green;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eaten {\n    ask wolves within: 1 {\n      do die;\n    }\n  }\n}\n\nspecies wolves {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask sheep within: 1 {\n      do die;\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species sheep aspect: base;\n      species wolves aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "How can I draw a red line in my display from point A to B?",
        "answer": "display view type: opengl {\ngraphics \"Lines\" {\n  draw line([{xa,ya}, {xb,yb}]); color: #red;\n}\n}",
        "nickname": "Arno"
      },
      {
        "question": "Define a global variable that computes at each step the number of people agents with the attribute is_happy is true.",
        "answer": "global {\n\t// other attributes\n\tint nb_happy_people <- 0 update: people count each.is_happy ;\n\t//...\n}",
        "nickname": "patrick"
      },
      {
        "question": "Right me a code that simulates an agent moving in an environment with obstacles. It must define the agent's perception distance, computes its field of vision, and controls its movement behavior. The GUI provides a visual representation of the environment and the agent's actions and field of vision.",
        "answer": "/**\n* Name: fieldofvision\n* Author: Patrick Taillandier\n* Description: This model illustrate how to use the masked_by operator to compute the field of vision of an agent (with obtsacles)\n* Tags: perception, spatial_computation, masked_by\n*/\n\nmodel fieldofvision\n\nglobal {\n\t//number of obstacles\n\tint nb_obstacles <- 20 parameter: true;\n\t\n\t//perception distance\n\tfloat perception_distance <- 40.0 parameter: true;\n\t\n\t//precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation\n\tint precision <- 600 parameter: true;\n\t\n\t//space where the agent can move.\n\tgeometry free_space <- copy(shape);\n\tinit {\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tshape <- rectangle(2+rnd(20), 2+rnd(20));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people  {\n\t\t\tlocation <- any_location_in(free_space);\n\t\t}\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nspecies people skills: [moving]{\n\t//zone of perception\n\tgeometry perceived_area;\n\t\n\t//the target it wants to reach\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\tif (perceived_area = nil) or (perceived_area.area < 2.0) {\n\t\t\t\t//if the agent has no target and if the perceived area is empty (or too small), it moves randomly inside the free_space\n\t\t\t\tdo wander bounds: free_space;\n\t\t\t} else {\n\t\t\t\t//otherwise, it computes a new target inside the perceived_area .\n\t\t\t\ttarget <- any_location_in(perceived_area);\n\t\t\t}\n\t\t} else {\n\t\t\t//if it has a target, it moves towards this target\n\t\t\tdo goto target: target;\n\t\t\t\n\t\t\t//if it reaches its target, it sets it to nil (to choose a new target)\n\t\t\tif (location = target)  {\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\n\t}\n\t//computation of the perceived area\n\treflex update_perception {\n\t\t//the agent perceived a cone (with an amplitude of 60°) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); \n\t\t\n\t\t//if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,precision);\n\n\t\t}\n\t}\n\t\n\taspect body {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t}\n\taspect perception {\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t\tdraw circle(1) at: target color: #magenta;\n\t\t}\n\t}\n}\n\nexperiment fieldofvision type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tdisplay view{\n\t\t\tspecies obstacle;\n\t\t\tspecies people aspect: perception transparency: 0.5;\n\t\t\tspecies people aspect: body;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "generates a code snippet that creates 1,000 inhabitant agents and places each one in a randomly chosen location in one of the building agents chosen randomly. ",
        "answer": "create inhabitant number: 1000 {\n\tbuilding a_building <- one_of(building);\n\tlocation <- any_location_in(a_building);\t \n}",
        "nickname": "Patrick"
      },
      {
        "question": "How to get the id of an agent? ",
        "answer": "agent a;\nint id <- int(a);",
        "nickname": "patrick"
      },
      {
        "question": "Create a random number of agent and make them move around randomly",
        "answer": "global {\n\nint rnd_number <- 100;\n\ninit {\ncreate a number:rnd(rnd_number);\n}\n\n}\n\nspecies a skills:[moving]{\n\nreflex move_random {\ndo wander;\n}\n\n}",
        "nickname": "Kevin"
      },
      {
        "question": "write some code that creates an hexagonal grid and displays it. The model will pick a random cell, change its color to red and its neighbours' colors to green",
        "answer": "/**\n* Name: HexagonalGrid\n* Author: Patrick Taillandier\n* Description: \n* Tags: grid, hexagon\n*/\n\nmodel HexagonalGrid\n\nglobal {\n\tstring orientation <- \"horizontal\" among: [\"horizontal\", \"vertical\"] parameter: true;\t\n\t\n\tinit {\n\t\task cell {color <- #white;}\n\t}\n\treflex show_neighborhood {\n\t\task cell {color <- #white;}\n\t\task one_of(cell) {\n\t\t\tcolor <- #red;\n\t\t\task neighbors {\n\t\t\t\tcolor <- #green;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";\n\n\nexperiment hexagonal type: gui{\n\toutput  synchronized:true{\n\t\tdisplay view type: 3d{\n\t\t\tgrid cell border: #black ;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "a model simulates the flow of water in a landscape with cells are created in the initialization (init) block of the global scope. Each cell is located at a random point within a square of side length 100 and has a random initial water level. The reflex flow block defines the behavior of the cells, which is to distribute their water to neighboring cells if they have more water than the average of their neighbors. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the cells.",
        "answer": "model HydrologyModel\n\nglobal {\n  int nb_cells <- 100;\n  geometry shape <- square(100);\n  init {\n    create cells number: nb_cells {\n      location <- one_of(shape);\n      water_level <- rnd(100);\n    }\n  }\n}\n\nspecies cells {\n  float water_level;\n  aspect base {\n    draw square(1) color: rgb(0, 0, water_level);\n  }\n  reflex flow {\n    float total_water = sum_of(cells neighbors_at: 1, each.water_level);\n    float avg_water = total_water / count(cells neighbors_at: 1);\n    if (water_level > avg_water) {\n      float flow = (water_level - avg_water) / 2;\n      water_level <- water_level - flow;\n      ask cells neighbors_at: 1 {\n        water_level <- water_level + flow / count(cells neighbors_at: 1);\n      }\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species cells aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Using the network plugin, write an action that send the string \"Hello\" to all agents connected to the network",
        "answer": "action broadcastHello\n{\n do send to:\"ALL\" contents:\"Hello\";\n}\n",
        "nickname": "Guest"
      },
      {
        "question": "model simulates the diffusion of water in a landscape with cells are created in the initialization (init) block of the global scope. Each cell is located at a point in a grid of size grid_size and has a random initial water level. The reflex diffuse block defines the behavior of the cells, which is to distribute their water to neighboring cells based on the difference between their water level and the average water level of their neighbors. The amount of water that is diffused is controlled by the diffusion_rate. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the cells.\n",
        "answer": "model WaterDiffusion\n\nglobal {\n  int grid_size <- 50;\n  float diffusion_rate <- 0.01;\n  init {\n    create cells number: grid_size * grid_size {\n      location <- cell_of(self, shape);\n      water_level <- rnd(100);\n    }\n  }\n}\n\ngrid cells width: grid_size height: grid_size neighbors: 8 {\n  float water_level;\n  reflex diffuse {\n    float total_water = sum_of(cells neighbors_at: 1, each.water_level);\n    float avg_water = total_water / count(cells neighbors_at: 1);\n    float diff = (water_level - avg_water) * diffusion_rate;\n    water_level <- water_level - diff;\n    ask cells neighbors_at: 1 {\n      water_level <- water_level + diff / count(cells neighbors_at: 1);\n    }\n  }\n  aspect base {\n    draw square(1) color: rgb(0, 0, water_level);\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      grid cells aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Generates a species of agent called road, which can be used to define a speed coefficient according to the number of agents on the road, in order to simulate traffic jams. This species has 3 attributes: capacity of type float, which corresponds to its length /30 + 1; nb_drivers of type integer, which is initialized at 0.0 and is calculated at each time step by the number of inhabitant agents within 1m of the road; speed_rate of type float, which is initialized at 1.0 and is recalculated at each time step by an exponential of -nb_drivers/capacity. \n",
        "answer": "species road {\n\tfloat capacity <- 1 + shape.perimeter / 30#m;\n\tint nb_drivers <- 0 update: length(inhabitant at_distance 0.1);\n\tfloat speed_rate <- 1.0 update: exp(-nb_drivers / capacity) min: 0.1;\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Given a model file named \"Multi-simulation.gaml\" containing a single species named dummy to display, how to create an experiment launching 2 simulations and displaying the agents of each simulation in 2 different displays?",
        "answer": "import \"Multi-simulation.gaml\"\n\n\n\nexperiment main2 type: gui {\n\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default)\n\t\tcreate simulation ;\n\t}\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n\n}",
        "nickname": "patrick"
      },
      {
        "question": "Give me an example of a multi-simulation experiment.",
        "answer": "import \"Multi-simulation.gaml\"\n\n\n\nexperiment main2 type: gui {\n\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default)\n\t\tcreate simulation ;\n\t}\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n\n}",
        "nickname": "Guest"
      },
      {
        "question": "create a model that write the 10 first number of the Fibonacci list in the console  ",
        "answer": "global {\n\nlist<int> fibo <- [0,1]\n\ninit {\n\nloop times:10 {\nfibo <+ fibo[length(fibo)-1] + fibo[length(fibo)-2];\nwrite last(fibo);\n}\n\n}\n\n}",
        "nickname": "Kevin"
      },
      {
        "question": "write a model to showcase the different ways to compute shortest paths on a grid between two points (a source and a goal) picked randomly. Display the source and goal as respectively green and red circles of 1m diameter. Display the path with lines connecting each step, and each step being represented by a triangle",
        "answer": "/**\n* Name:  Computation of the shortest path on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how to compute the shortest path from a grid (with the 4 algorithms).\n* Tags: grid, obstacle, shortest_path\n*/\n\nmodel Grid\n\nglobal {\n\t\n\t/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https://harablog.wordpress.com/2011/09/07/jump-point-search/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tstring scenario <- \"wall\" among: [\"random\", \"wall\"] parameter: true;\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tfloat obstacle_rate <- 0.1 min: 0.0 max: 0.9 parameter: true;\n\tint grid_size <- 50 min: 5 max: 100 parameter: true;\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\tinit toto {    \n\t\tif (scenario = \"wall\") {\n\t\t\task cell {is_obstacle <- false;}\n\t\t\tint x_max <- round(grid_size * 2/3);\n\t\t\tloop i from: 2 to:x_max {\n\t\t\t\tcell[i, 3].is_obstacle <- true;\n\t\t\t\tcell[i, grid_size - 4].is_obstacle <- true;\n\t\t\t}\n\t\t\tloop i from: 3 to: grid_size - 4 {\n\t\t\t\tcell[x_max, i].is_obstacle <- true;\n\t\t\t}\n\t\t\task cell {color <- is_obstacle ? #black : #white;}\n\t\t}\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell width: grid_size height: grid_size neighbors: neighborhood_type optimizer: algorithm{\n\tbool is_obstacle <- flip(0.1);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\n\t\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type: 2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tgraphics \"elements\" {\n\t\t\t\tdraw circle(1) color: #green at: source border: #black;\n\t\t\t\tdraw circle(1) color: #red at: goal  border: #black;\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: point(v);\n\t\t\t\t}\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Generates an aspect called \"threeD\" that displays the agent's geometry with an extrusion value of \"height\" and 2 textures: the \"../includes/roof.png\" file for the roof and the \"../includes/texture5.jpg\" file for the facade.",
        "answer": "aspect threeD {\n\tdraw shape depth: height texture: [\"../includes/roof.png\",\"../includes/texture5.jpg\"];\n}",
        "nickname": "Patrick"
      },
      {
        "question": "How to launch a second simulation with given parameters values: its global values nb_agents (value = 5), agent_speed (value = 5.0) and agent_color (value = #red) ?",
        "answer": "experiment main type: gui {\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default) with the following parameters\n\t\tcreate simulation with: [nb_agents:: 5, agent_speed:: 5.0, agent_color:: #red];\n\t\t \n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Using the network plugin, write a code snippet of an action that display all the different attributes from a received message",
        "answer": "action displayMessageInformation(message mess)\n{\n  write(\"content of the message \" + mess.contents);\n  write(\"sender of the message \" + mess.sender);\n  write(\"is the message unread ? \" + mess.unread);\n  write(\"message emission timestamp \" +  mess.emission_timestamp);\n  write(\"message reception timestamp \" + mess.recention_timestamp);\n}",
        "nickname": "Guest"
      },
      {
        "question": "Generates a code snippet that allows an agent to move towards the destination \"target\" on the \"road_network\" graph, and stores the path taken in the \"followed_path\" variable.",
        "answer": "path followed_path <- goto(target: target, on: road_network,  return_path: true);\n\t\t",
        "nickname": "Patrick"
      },
      {
        "question": "How to use a loop to display each element of a list one after the other?",
        "answer": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\n\nloop id from: 0 to: length(list_of_string) - 1 {\n    write \"\" + id +\"th element of \" + list_of_string + \": \" + list_of_string[i];\n}",
        "nickname": "patrick"
      },
      {
        "question": "write me a species to represent people and that could be displayed in many different ways using different displays",
        "answer": "species people {\n\tstring aspect_type;\n\trgb color_transparency <- rgb(#darkred, 0.4 / (1 + int(self)));\n\n\t// aspect blocks defines how each agent is displayed\n\taspect default {\n\t// The draw statement takes any drawable objects (geometry, text, image)...\n\t// The aspect color: defines the inner color of the geometry or the color of the text.\n\t// The aspect border: defines the geometry border color.\n\t\tdraw circle(0.5) color: #red border: #yellow;\n\t\tdraw aspect_type color: #black at: location + {0, 4, 1} anchor: #bottom_center depth: 3;\n\t}\n\n\t// In an aspect, it is possible to draw several layers one after the other.\t\n\taspect simple {\n\t\tdraw circle(0.5) color: #grey border: #darkgrey;\n\t\t// The facet wireframe: sets whether the drawn geometry is plain or empty.  \n\t\tdraw circle(1.0) border: #darkgreen wireframe: true;\n\t\tdraw square(3.0) border: #darkgreen wireframe: true;\n\t}\n\n\taspect big_square_for_transparency {\n\t\tdraw square(3.0) color: #darkblue border: #black;\n\t}\n\n\taspect big_circle_with_transparency {\n\t\tdraw circle(5.0) color: color_transparency border: #black;\n\t}\n\n\t// The object to draw can be text.\n\t// The draw can be configured using the color: facet and the font: one.\n\t// font: facet is expecting a font obbject composed by the name of the font, its size and #bold/#italic/#plain/#bold+#italic.\t\n\taspect simple_text {\n\t// perspective: facet specifies whether to render the text in perspective or facing the user.\t\t\n\t\tdraw \"Agent: \" + name + \"(rotate!)\" at: location + {0, 8, 0} color: #green font: font(\"Arial\", 10, #bold) perspective: false;\n\t\tdraw \"Agent: \" + name at: location + {0, 6, 0} color: #blue font: font(\"SansSerif\", 15, #italic) perspective: true;\n\t}\n\n\t// When a line is drawn, it could be interesting to also draw an arrow at one of the extremities of the line\n\taspect arrows {\n\t// begin_arrow: and end_arrow: facets are used to define the size of the drawn line.\n\t// width: facet can be used to increase the width of a line \n\t// (the use of width with other geometry will provide unexpected result, as it increase each line of the geometry)\n\t\tdraw line([self.location, people(8).location]) color: #orange end_arrow: 1 begin_arrow: 2.2 width: 3.0;\n\t}\n\n\t// at (point): location where the shape/text/icon is drawn\n\t// rotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}\n\t// The elements drawn are by default located on the agent location, but they can be moved anywhere in the environment.\n\t// They can also be rotated.\t\t\n\taspect locate_geometry {\n\t\tdraw square(1.0) color: #silver border: #black at: world.location rotate: 45;\n\t\tdraw \"Agent in center\" color: #green font: font(\"Arial\", 15, #bold) at: world.location + {0.0, 2.0, 0.0} anchor: #bottom_center;\n\t}\n\n\t// In an OpenGL display, the various geometries can be displayed in 3d, or more specifically with a depth (facet depth:).\n\t// for example, a circle with depth, will be displayed as a cylinder.\n\t// These 3D objects be displayed taken into account the light or not with the lighted facet:\n\taspect col3D {\n\t\tdraw circle(1.0) color: #tomato depth: 5.0 lighted: true;\n\t\tdraw sphere(1.0) at: (location - {2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw cube(1.0) at: (location - {-2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw square(1.0) at: (location - {-2.0, 2.0, 0.0}) color: #tomato depth: 5.0 lighted: true;\n\t}\n\n\t// In a 3D display (openGL), agents can add texture (i.e. a picture on the geometry) and can be lighted or not.\n\taspect textured {\n\t\tdraw sphere(2.0) color: #tomato;\n\t\tdraw sphere(2.0) at: (location - {4.0, 0.0, 0.0}) color: #tomato lighted: false;\n\t\tdraw sphere(2.0) at: (location - {-4.0, 0.0, 0.0}) color: #tomato texture: wood0_image_file;\n\t}\n\n\t// When an agent is displayed drawing a picture, that picture can be resize (using the size: facet).\n\taspect image {\n\t\tdraw wood0_image_file size: {50.0, 10.0, 0.0};\n\t}\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "generate a code snippet that defines a list of string called \"list_of_string\" composed of three elements \"A\", \"B\" and \"C\"",
        "answer": "list<string> list_of_string <- [\"A\",\"B\",\"C\"];\n\t",
        "nickname": "Patrick"
      },
      {
        "question": "How can I repeat a set of statements while iterating over a full container?\t\t\n",
        "answer": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\n\nloop elt over: list_of_string {\n   write sample(elt);\n}",
        "nickname": "patrick"
      },
      {
        "question": "Generates a code snippet that loops over all the elements of the \"list_of_string\" list and displays them in the console. ",
        "answer": "loop elt_of_list over: list_of_string {\n\twrite sample(elt_of_list);\n}\t\t",
        "nickname": "Patrick"
      },
      {
        "question": "How to use a while-loop to display all the elements of a list of string values?",
        "answer": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\nint id <- 0;\n\nloop while: (id < length(list_of_string) {\n   write \"\" + id +\"th element of \" + list_of_string;\n   write \"  \" + sample(list_of_string[id]); \t\t\t\n   // id should be incremented ... otherwise the loop while never end.\n   id <- id + 1;\n}\t\t\t\t\t\n",
        "nickname": "patrick"
      },
      {
        "question": "code a model named DEM, in global there is variable dem_file of type file, pointed to a raster file DEM_500x500.tif. create a grid agent cel_dem using the dem_file with the attribute elevation of type float. Init value of elevation is the grid value.",
        "answer": "model load_DEM\n\nglobal {\n\t\n\tfile dem_file <- grid_file(\"../includes/DEM/DEM_500x500.tif\");\n}\ngrid cell_dem file: dem_file {\n\tfloat elevation <- float(grid_value);\n}\n",
        "nickname": "Quang"
      },
      {
        "question": "Generate a code snippet that define a matrice called  \"mat\" that has a size of 3x3 filled with 0.\n",
        "answer": "matrix mat <- {3,3} matrix_with 0; \n\t",
        "nickname": "Patrick"
      },
      {
        "question": "Generate a reflex of the plot grid species that describes the cabbage biomass grows following a logistic function with a growth rate equal to 0,2 and limited by the carry_capacity of the plot.",
        "answer": "\treflex grow {\n\t\tif(carrying_capacity != 0){\n\t\t\tbiomass <- biomass * (1 + 0.2 * (1 - biomass/carrying_capacity));\t\n\t\t}\n\t}\n",
        "nickname": "patrick"
      },
      {
        "question": "Write a model that creates a random directed graph (with 20 nodes and 20 edges), and save it in the dot format.",
        "answer": "model SaveGraph\n\nglobal {\n\tinit {\n\t     graph the_graph <- generate_random_graph(20, 20, true,node_agent, edge_agent);\n\t\t\n\t     //save the graph \t\t\n\t     save the_graph to:\"../results/my_graph.dot\" format:\"dot\";\t\t\n\t}\n} \n  \n//species that represent the nodes of the graph\nspecies node_agent {\n\taspect default {\n\t\tdraw circle(1.0) color:#red border: #black;\n\t}\n}\n\n//species that represent the edges of the graph\nspecies edge_agent {\n\taspect default {\n\t\tdraw shape color:#black end_arrow: 1.0;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies node_agent;\n\t\t\tspecies edge_agent;\n\t\t}\n\t}\n}\n",
        "nickname": "patrick"
      },
      {
        "question": "write a code snippet that generate a message containing a map with data and send the message to a given agent in the network identified by its name.",
        "answer": "\n\t\naction generateAndSendMessage(string dest)\n{\t\n   map<string,unknown> mess <- [\"int\"::10 , \"bool\"::true, \"list\"::[0,1,2]]; \n   do send to:dest contents:mess; \t\n}",
        "nickname": "Guest"
      },
      {
        "question": "create an experiment sim type GUI. Adding a display window named DEM type 3d, show the grid cell_dem as mesh where no data is -9999.",
        "answer": "experiment sim type: gui {\n\toutput {\n\t\t\n\t\tdisplay \"DEM\" type: 3d \t\t\n\t\t\tmesh cell_dem no_data:-9999;\n\t\t}\n\n\t}\n}\n",
        "nickname": "Quang"
      },
      {
        "question": "Write a model that creates a random directed graph (with 30 nodes and 20 edges), and save it in the gml format.\n\n",
        "answer": "model SavetoGraph\n\nglobal {\n\tinit {\n\t     graph the_graph <- generate_random_graph(30, 20, true,node_agent, edge_agent);\n\t\t\n\t     //save the graph \t\t\n\t\tsave the_graph to:\"../results/my_graph.gml\" format:\"gml\";\n\t}\n} \n  \n//species that represent the nodes of the graph\nspecies node_agent {\n\taspect default {\n\t\tdraw circle(1.0) color:#red border: #black;\n\t}\n}\n\n//species that represent the edges of the graph\nspecies edge_agent {\n\taspect default {\n\t\tdraw shape color:#black end_arrow: 1.0;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies node_agent;\n\t\t\tspecies edge_agent;\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Write a model that: defines the people species, \ncreate 2000  people agents randomly located in the environment, displays the agentswith an aspect (named c) drawing the agent as a circle of radius 2, with an inner color red, and border color is black.",
        "answer": "model my_model\n\nglobal {\n\tinit {\n\t\tcreate people number: 2000;\n\t}\n}\n\nspecies people{ \n     aspect c {\n         draw circle(1) color: #red border: #black;\n}\n\nexperiment Schelling1 type: gui {\n\toutput {\n\t\tdisplay people_display {\n\t\t\tspecies people aspect: c;\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "generate a code snippet that defines an attribute called int of type integer with an initial value of 100 and that write its value in the console each time its value changes",
        "answer": "int att <- 100 on_change: {write att;};",
        "nickname": "Patrick"
      },
      {
        "question": "How to display the agents of 2 species named people and building, with aspects named respectively ci and sq?",
        "answer": "experiment exp type: gui {\n\toutput {\n\t\tdisplay agents_display {\n\t\t\tspecies people aspect: ci;\n\t\t\tspecies building aspect: sq;\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "create a grid of cells of size 10 by 10, each containing a random floating number that will be mapped to a color for the visualization",
        "answer": "global {\n\nfield f <- field(10,10);\n\ninit {\nloop x from:0 to:10 { loop y from:0 to:10 { f[{x,y}] <- rnd(1.0); }}\n}\n\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay m {\n\t\t\tmesh f color:gradient([#pink,#magenta,#purple]);\n\t\t}\n\t}\n}",
        "nickname": "Kevin"
      },
      {
        "question": "write me a model with an experiment that will display a species differently depending on the value of a boolean variable called dark_mode. The species will be called dummy because I don't really care. When dark_mode is true the dummy agents will be represented by a dark red circle, when it's false by a normal red circle. Also change the display's background from white when dark_mode is false to black when it's true",
        "answer": "/**\n* Name: Conditional_aspect_selection\n* Author: Baptiste Lesquoy\n* Tags: \n*/\n\n\nmodel Conditional_aspect_selection\n\nglobal {\n\t\n\tbool dark_mode <- false;\n\tfont my_font <- font(\"Helvetica\", 16, #bold);\n\tinit {\n\t\tcreate dummy number:10;\n\t}\n\t\n}\n\nspecies dummy {\n\t\n\taspect light {\n\t\tdraw circle(2) color:#red;\n\t}\n\taspect dark {\n\t\tdraw circle(2) color:#darkred;\n\t}\n}\n\n\nexperiment test {\n\tparameter \"Toggle dark mode\" var:dark_mode;\n\toutput{\n\t\tdisplay main background:dark_mode?#black:#white{\n\t\t\tspecies dummy {\n\t\t\t\tif dark_mode {\n\t\t\t\t\tdraw dark;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdraw light;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tgraphics \"Instructions\"{\n\t\t\t\tdraw \"Toggle the dark mode parameter and run a simulation step\" at:{5,5} color:dark_mode?#white:#black font:my_font;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Define a species people with an attribute color (of type rgb). The attribute is randomly initialized to the value #red or #yellow (with a probability of 50% for each). The agents can be displayed using an aspect drawing agents as a circle of radius 1 and using the color as inner color of the circle.",
        "answer": "species people {\n\t\n\trgb color;\n\t\n\tinit {\n\t\tif( flip(0.5) ) {\n\t\t\tcolor <- #red;\n\t\t} else {\n\t\t\tcolor <- #yellow;\n\t\t}\n\t}\n\t\n\taspect asp_circle {\n\t\tdraw circle(1.0) color: color ;\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "How to define a species people with a color attribute (of type rgb), initialized to a random color between #red and #yellow with equal probability.",
        "answer": "species people {\n\trgb color;\n\t\n\tinit {\n\t\tcolor <- (flip(0.5) ? #red : #yellow);\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "How to define a species people with a color attribute (of type rgb), initialized to a random color between #red and #yellow with equal probability.",
        "answer": "species people {\n\trgb color <- (flip(0.5) ? #red : #yellow);\n}",
        "nickname": "patrick"
      },
      {
        "question": "Define a species people that moves randomly in a continuous space a each simulation step.",
        "answer": "species people {\n\n\treflex move {\n\t\tlocation <- any_location_in(world.shape);\n\t}\n\n}",
        "nickname": "patrick"
      },
      {
        "question": "Create an action, called proxima, that will return the distance between an agent and the closest other agent",
        "answer": "global {\n\naction proxima (agent a) {\nreturn agent_closest_to(a) distance_to a;\n}\n\n}",
        "nickname": "Kevin"
      },
      {
        "question": "Create a model to study the spread of influence or activity across a spatial environment and visualize it as a heatmap.",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a model demonstrating the use of overlay layers in graphical displays.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Show how to implement overlay layers to highlight different types of elements on a map.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a global block defining 3 global variables: rate_similar_wanted (initial value : 0.4), neighbours_distance (initial value : 5.0), nb_people (initial value : 100). It creates nb_people agents of the species people.",
        "answer": "global {\n\tfloat rate_similar_wanted <- 0.4;\n\tfloat neighbours_distance <- 5.0;\n\tint nb_people <- 100;\n\tinit {\n\t\tcreate people number: nb_people;\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Develop a visualization technique to represent various geographical features with distinct colors and labels using overlay layers.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Demonstrate the integration of overlay layers with a grid-based display to enhance visualization of spatial data.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a display to show my two lists of values coslist and sinlist in a series chart. I want the x axis to be labelled \"#points to draw at each step\", coslist should be labelled \"Cosinus\" and be displayed as a blue line and sinlist should be labelled \"Sinus\" and displayed as a red line. The display will be called \"long_series\"",
        "answer": "\t\tdisplay \"long_series\" type: 2d {\n\t\t\tchart \"Long series values\" type: series x_label: \"#points to draw at each step\" memorize: false {\n\t\t\t\tdata \"Cosinus\" value: coslist color: #blue marker: false style: line;\n\t\t\t\tdata \"Sinus\" value: sinlist color: #red marker: false style: line;\n\t\t\t}\n\n\t\t}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Illustrate the concept of overlay layers in a graphical interface, allowing for the display of additional information on top of existing elements.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Design a simulation showcasing the versatility of overlay layers for representing different categories of objects within a spatial environment",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Implement an overlay layer system for a 3D map visualization, allowing for the dynamic highlighting of specific regions or features.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Give me a sample complete model which shows how to create agents by importing data from a CSV file. The csv file for example is the sample iris data that comes with GAMA. The model reads the CSV file, creates an agent for each line of the CSV, and finally links its attributes to columns of the CSV File.",
        "answer": "model CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t//create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t//we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate iris from:csv_file( \"../includes/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}",
        "nickname": "julius"
      },
      {
        "question": "Develop a tutorial on building and displaying heatmaps",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "fill my list coslist with the values of cos(x) with x varying from 0 to 1000",
        "answer": "loop x from: 0 to: 1000 {\n\tadd cos(x) to: coslist;\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Explore the utilization of overlay layers in a graphical user interface to provide contextually relevant information alongside spatial data.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Wrote a model that will write \"you lose\" in the consol until a coin flip is won",
        "answer": "global {\n\ninit {\n\nloop while:flip(0.5) { write \"YOU LOSE!\"; }\n\n}\n\n}",
        "nickname": "Kevin"
      },
      {
        "question": "Create a graphical model that utilizes overlay layers to annotate a grid-based map with textual labels and colored markers for various geographic elements",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Develop a tutorial on incorporating overlay layers into 3D visualizations to display multiple layers of information in a coherent manner.",
        "answer": "/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*/\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Define a people species, with an attribute named neighbours (containing the list of people agents in the neighborhood). Its value is computed at each step with the people agents that are at a distance lower or equal to neighbours_distance global parameter.\n",
        "answer": "species people {\t\n\n\tlist<people> neighbours update: people at_distance neighbours_distance;\n\n}",
        "nickname": "patrick"
      },
      {
        "question": "Define a people species, with an attribute named neighbours (containing the list of people agents in the neighborhood). Its value is computed at each step with the people agents that are at a distance lower or equal to neighbours_distance global parameter.\n",
        "answer": "species people {\t\n\n\tlist<people> neighbours ;\n\n     reflex update {\n        neighbours <- people at_distance neighbours_distance;\n\n}",
        "nickname": "patrick"
      },
      {
        "question": "Demonstrate how to use agent behaviors to dynamically update a heatmap representation of activity levels within a simulated space",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "I have data stored in the variable gauss_distrib. Create an experiment to display it in a bar chart",
        "answer": "experiment \"Example of Distribution\" type: gui {\n\toutput {\n\t\tdisplay \"Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Gauss Distribution\" type: histogram {\n\t\t\t\tdatalist (gauss_distrib at \"legend\") value: (gauss_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Explore the creation of heatmaps using agent behavior data and visualize them using various color palettes and rendering techniques.",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Demonstrate the use of agent-based modeling to generate data for a heatmap and visualize it in different ways",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "model simulates a predator-prey relationship in a marine environment in which fish and hunters are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The hunters have an additional reflex eat block, which causes any fish within a distance of 1 to die. The fish have an additional reflex eaten block, which causes them to die if a hunter is within a distance of 1. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.",
        "answer": "model FishHunterModel\n\nglobal {\n  int nb_fish <- 100;\n  int nb_hunters <- 10;\n  geometry shape <- square(100);\n  init {\n    create fish number: nb_fish {\n      location <- one_of(shape);\n    }\n    create hunters number: nb_hunters {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies fish {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eaten {\n    ask hunters at_distance 1 {\n      do die;\n    }\n  }\n}\n\nspecies hunters {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask fish at_distance 1 {\n      do die;\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species fish aspect: base;\n      species hunters aspect: base;\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Create a simulation illustrating how heatmaps can be generated and displayed to represent the concentration of activity or events within a specified area.",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Define a people species, with 3 attributes: neighbours, that is the list of people agents at a distance lower than the neighbours_distance global variable, color (of type rgb), and is_happy, a boolean attribute initially set to false. \nDefine a reflex named computing_similarity with the following behavior. If neighbours is empty, set the rate_similar to 1.0. Otherwise, compute the number of neighbours, then the number of neighbours with the same colour as the agent, then set the rate_similar to the number of similar neighbours divided by the number of neighbours\nCompute the happiness state of the agent: is_happy is true if rate_similar is greater than the global variable rate_similar_wanted, and false otherwise.",
        "answer": "species people {\n\t// other attributes\n\tlist<people> neighbours update: people at_distance neighbours_distance;\n\tbool is_happy <- false;\n        rgb color;\n\n\treflex computing_similarity {\n\t\tfloat rate_similar <- 0.0;\n\t\tif (empty(neighbours)) {\n\t\t\trate_similar <- 1.0;\n\t\t} else {\n\t\t\tint nb_neighbours <- length(neighbours);\n\t\t\tint nb_neighbours_sim <- neighbours count (each.color = color);\n\t\t\trate_similar <- nb_neighbours_sim /nb_neighbours ;\n\t\t}\n\t\tis_happy <- rate_similar >= rate_similar_wanted;\n\t}\n\t//other reflex and aspect definition\n}",
        "nickname": "patrick"
      },
      {
        "question": "Develop a model showcasing the generation and visualization of heatmaps based on the movement of agents within a simulated environment.",
        "answer": "/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Can you create a line in 3D between point {x1,y1,z1} and {x2,y2,z2}?",
        "answer": "geometry line3D <- line([{x1,y1,z1}, {x2,y2,z2}]);",
        "nickname": "Arno"
      },
      {
        "question": "Can you create a square of size 10 at location 10,20 ?",
        "answer": "geometry polygon2D <- square(10) at_location {10,20};",
        "nickname": "Arno"
      },
      {
        "question": "here is my model for the ants algorithm, create an experiment that will display all kind of data in charts of that model.\n\nmodel ants\n\nglobal {\n\t//Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t//Evaporation value per cycle for the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t//Diffusion rate for the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;\n\t//Size of the grid\n\tint gridsize <- 75 ;\n\t//Center of the grid to put the location of the nest\n\tpoint center const: true <- { (gridsize / 2),  (gridsize / 2)} ;\n\tfile types const: true <- (pgm_file('../images/environment75x75.pgm')) ;\n\tint food_gathered <- 0 ;   \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t//Ant are placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t\n\t//Reflex to diffuse the road of pheromon on the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n\n\n}\n\n//Grid to discretize space for the food and the nest\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tbool multiagent <- true ;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ; \n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? #violet:((food > 0)? #blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? #white : ((road > 0.5)? (#grey) : ((road > 0.2)? (#lightgrey) : (#darkgray)))))) update: isNestLocation ? #violet:((food > 0)? #blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? #white : ((road > 0.5)? (#grey) : ((road > 0.2)? (#lightgray) : (#darkgray)))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tint nest const: true <- 300 - int(self distance_to center) ;\n\t\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tbool hasFood <- false ;\n\n\n\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   //Action to pick food\n\taction pick {\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t//Action to chose the best place according to the possible food in the neighbour cells\n\taction choose_best_place type: ant_grid {\n\t\tlist<ant_grid> list_places <- place.neighbors ;\n\t\tif (list_places count (each.food > 0)) > 0  {\n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t}\n\t\n\t//Initial state of the ant : wander until it finds food or find a road to follow\n\tstate wandering initial: true {\n\t\tdo wander amplitude:120.0 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ;\n\t}\n\t//State to carry food to the nest once the food is found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t//State to follow a road \n\tstate followingRoad {\n\t\tlocation <- (choose_best_place()) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\n\taspect default {\n\t\tdraw circle(1.0) wireframe: !hasFood color: #orange ; \n\t}\n}",
        "answer": "\nexperiment \"Experiment\" type: gui {\n\t//Parameters to play with  in the gui\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"wandering\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\n\treflex update_charts\n\t{\n\t\tnbants<-list<list<int>>([]);\n\t\tstatesnames<-list<string>([]);\n\t\tcategnames<-[\"empty\",\"carry\"];\n\t\tnbantsbydist<-list<list<int>>([]);\n\t\tloop x over:(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(ant count (each.state=x.state and !each.hasFood)),(ant count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tlist<int> nl<-list<int>([]);\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (ant count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n\t\t}\n\t\n\t}\n\t//The different displays\n\toutput {\n\t    layout horizontal([vertical([0::6721,2::3279])::5000,vertical([1::5000,horizontal([3::5000,4::5000])::5000])::5000]) tabs:true toolbars:true;\n\t\t\n\t\tdisplay Ants type: 2d antialias:false{\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant  ;\n\t\t}\n\t\tdisplay ProportionCarryFood  type: 2d {\n\t\t\tchart \"Proportions carrying: Pie\"  size: {0.5,0.5} position: {0, 0} type:pie\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(ant count (!each.hasFood)) color:#red;\n\t\t\t\tdata \"carry_food_ants\" value:(ant count (each.hasFood)) color:#green;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportions carrying: Radar\"  size: {0.5,0.5} position: {0.5, 0} type:radar\n\t\t\taxes:#white\n\n\t\t\t{\n\t\t\t\tdata \"empty\" value:(ant count (!each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:#red;\t\t\t\t\n\t\t\t\tdata \"carry\" value:(ant count (each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:#blue;\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportion: serie\"   size: {1.0,0.5} position: {0, 0.5} type:series \n\t\t\tseries_label_position: legend\n\t\t\tstyle:stack\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] accumulate_values:true \n\t\t\t\tvalue:[(ant count (!each.hasFood)),(ant count (each.hasFood))] \n\t\t\t\tcolor:[#red,#green];\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tdisplay CentroidPosition  type: 2d {\n\t\t\tchart \"Positions and History of Centroide and size by Carry state\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"avg-carry\",\"avg-empty\"] value:[mean((ant where (each.hasFood)) collect each.location),\n\t\t\t\t\tmean((ant where (!each.hasFood)) collect each.location)\n\t\t\t\t]\n\t\t\t\tmarker_size: [(ant count (each.hasFood))/20,(ant count (!each.hasFood))/20]\n\t\t\t\t\t color:[#red,#green] \n\t\t\t\t\t fill:false\n\t\t\t\t\t line_visible:true;\t\t\t\t\n\t\t\t\tdata \"empty_ants\" value:((ant where (!each.hasFood)) collect each.location) color:#red \n\t\t\t\taccumulate_values:false\n\t\t\t\tline_visible:false;\n\t\t\t\tdata \"carry_food_ants\" value:((ant where (each.hasFood)) collect each.location) \n\t\t\t\taccumulate_values:false\n\t\t\t\tcolor:#green line_visible:false;\n\n\t\t\t}\n\t\t}\t\n\t\tdisplay Distribution2dPosition  type: 2d {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.65,0.3} position: {0.05, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the Y positions\"   size: {0.3,0.7} position: {0.7, 0.28} type:histogram\n\t\t\treverse_axes:true\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist reverse(distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:reverse(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\n\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\n\t\t\tseries_label_position:none\n\t\t\t{\n\t\t\t\tdata  \"XYdistrib\"\n\t\t\t\t\tvalue:(distribution2d_of(ant collect each.location.x,ant collect each.location.y,10,0,100,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red]; \n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay DistributionPosition  type: 2d {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.92,0.3} position: {0, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the X positions- heatmap\"   size: {1.0,0.7} position: {0, 0.3} type:heatmap\n\t\t\tx_serie_labels: (distribution_of(ant collect each.location.x,10,0,100) at \"legend\")\n\t\t\ty_range:50\n\t\t\t{\n\t\t\t\tdata  \"Xdistrib\"\n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red];\n\t\t\t}\n\t\t}\t\n\t\t}\n\t}\t\n\n\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "basic structure of model simulates a fishery boat that moves in a marine environment and catches fish",
        "answer": "model Fishery\n\nglobal {\n  // Define global attributes here\n}\n\nspecies fish {\n  // Define fish attributes and behaviors here\n}\n\nspecies boat {\n  // Define boat attributes and behaviors here\n}\n\nexperiment FisheryExperiment type: gui {\n  // Define your experiment here\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "create an experiment to show me all different kind of bar charts available in gama. The data displayed doesn't matter",
        "answer": "\nexperiment \"Multiple displays\" type: gui {\n\toutput synchronized: true {\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false toolbars: false tray: false tabs: true;\t\n\t\tdisplay \"nice_bar_chart\"  type: 2d {\n\t\t\tchart \"Nice Cumulative Bar Chart\" type:histogram \n\t\t\t \tbackground: #darkblue\n\t\t\t \tcolor: #lightgreen \n\t\t\t \taxes: #lightgreen\n\t\t\t \ttitle_font: font('Serif', 32.0, #italic)\n\t\t\t \ttick_font: font('Monospaced', 14, #bold) \n\t\t\t \tlabel_font: font('Arial', 18, #bold) \n\t\t\t \tlegend_font: font('SanSerif', 14, #bold) \n\t\t\t \ty_range:[-20,40]\n\t\t\t \ty_tick_unit:10\n\t\t\t \tx_label:'Nice Xlabel'\n\t\t\t \ty_label:'Nice Ylabel'\n\t\t\t {\n\t\t\t\tdata \"BCC\" value:10*cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle:stack\n\t\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:10*sin(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:(cycle mod 10)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack  \n\t\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n\t\tdisplay \"data_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"data_cumulative_bar_chart\" type:histogram \n\t\t\tstyle:stack\n\t\t\tx_serie_labels:(\"cycle\"+cycle)\n\t\t\tx_range:5\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:cycle+1\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d {\n\t\t\tchart \"data_non_cumulative_bar_chart\" type:histogram \n\t\t\tx_serie_labels: [\"categ1\",\"categ2\"]\n\t\t\tstyle:\"3d\"\n\t\t\tseries_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n//\t\t\t\tstyle:stack\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n//\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:[cycle+1,cycle]\n//\t\t\t\tstyle: stack  \n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"datalist_bar_cchart\" type:2d {\n\t\t\tchart \"datalist_bar\" type:histogram \n\t\t\tseries_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend:[\"cycle\",\"cosinus normalized\",\"offsetted cosinus normalized\"] \n\t\t\t\t\tstyle: bar\n\t\t\t\t\tvalue:[cycle,(sin(100*cycle) +  1) * cycle/2,(sin(100*(cycle+30)) + 1) * cycle/2] \n\t\t\t\t\tcolor:[#green,#black,#purple];\n\t\t\t}\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type:histogram \n\t\t\tseries_label_position: yaxis\n\t\t\tx_label: \"my_time_label\"\n\t\t\t{\n\t\t\t\tdata \"unique data value\" \n\t\t\t\t\tvalue:cos(cycle*10) \n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay \"data_cumulative_style_chart\" type:2d {\n\t\t\tchart \"Style Cumulative chart\" type:histogram style:stack\n\t\t\t \t{ \n\t\t\t\tdata \"Step\" value:cos(100*cycle+40)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"Bar\" value:cos(100*cycle+60)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#green;\n\t\t\t\tdata \"Line\" value:cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#orange;\n\t\t\t\tdata \"Dot\" value:cos(100*cycle)*0.3\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#red;\n\t\t\t}\n\t\t} \n\n\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "GAML model for a fishery boat simulation\n\n",
        "answer": "model Fishery\n\nglobal {\n  // Define global attributes here\n  float fish_population <- 1000;\n  float boat_population <- 10;\n}\n\nspecies fish {\n  // Define fish attributes and behaviors here\n  float speed <- rnd(10);\n  reflex move {\n    do wander speed: speed;\n  }\n}\n\nspecies boat {\n  // Define boat attributes and behaviors here\n  float speed <- 20;\n  reflex move {\n    do wander speed: speed;\n  }\n  reflex catchFish {\n    ask fish within(10) {\n      do die;\n    }\n  }\n}\n\nexperiment FisheryExperiment type: gui {\n  // Define your experiment here\n  output {\n    display \"Fishery\" type: opengl {\n      species fish color: rgb(0,255,0);\n      species boat color: rgb(255,0,0);\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "write a code snippet that contains a reflex that create a message containing a map with strings as keys and a int type as value and sent it to a given agent identified by its name. The name of the map is : \"data\".\n\nwrite a reflex capable of reading the message generated from the previous reflex.",
        "answer": "action sendMessageWithMap(string dest)\n{\n  do send to: dest contents:[\"data\"::map([\"data1\"::30,\"data2\"::10])];\n}\n\n\nreflex fetchMessage when:has_more_message()\n{\t\n  loop while:has_more_message()\n  {\n    message mess <- fetch_message();\n    map<string, unknown> data <- mess.contents[\"data\"];\n    loop index over: data \n    {\n\twrite(index);\t\t\n    }\n  }\n}",
        "nickname": "Guest"
      },
      {
        "question": "How to create a line starting from point x1,y1 to point  x2,y2 ?",
        "answer": "geometry line <- line([{x1,y1}, {x2,y2}]);",
        "nickname": "Arno"
      },
      {
        "question": "I want an example of code where `field` is used to represent an environment based on a Digital Elevation Model (DEM).",
        "answer": "grid_file dem_file <- file(\"../includes/DEM_100m_PP.asc\");\n\nfield terrain <- field(dem_file) ;\n\nfield flow <- field(terrain.columns,terrain.rows);\n\ngeometry shape <- envelope(dem_file);",
        "nickname": "z"
      },
      {
        "question": "What if I want to create different layers of that field to store information, like in an image with bands. Can you show that with the fields you gave?",
        "answer": "list<point> points <- flow points_in shape;\n\nmap<point, bool> done <- points as_map (each::false);\n\nmap<point, float> heights <- points as_map (each::height(each));\n\nlist<point> water <- points where (flow[each] > 0) sort_by (heights[each]);\n\nloop p over: points - water {\n\tdone[p] <- true;\n}\n",
        "nickname": "z"
      },
      {
        "question": "GAML model for a fishery boat simulation that Fish now have an age attribute and a reproduce behavior. They can reproduce after they reach a certain age, creating new fish agents.\nBoats now have a fuel attribute. They consume fuel as they move, and they stop moving when they run out of fuel",
        "answer": "model Fishery\n\nglobal {\n  float fish_population <- 1000;\n  float boat_population <- 10;\n  float reproduction_rate <- 0.1; // Fish reproduction rate\n  float fuel_consumption_rate <- 0.05; // Boat fuel consumption rate\n}\n\nspecies fish {\n  float speed <- rnd(10);\n  int age <- 0;\n  reflex move {\n    do wander speed: speed;\n  }\n  reflex reproduce {\n    if (age > 1) { // Fish can reproduce after 1 year\n      create fish number: reproduction_rate;\n    }\n  }\n  reflex aging {\n    age <- age + 1;\n  }\n}\n\nspecies boat {\n  float speed <- 20;\n  float fuel <- 100; // Initial fuel\n  reflex move {\n    if (fuel > 0) {\n      do wander speed: speed;\n      fuel <- fuel - fuel_consumption_rate;\n    }\n  }\n  reflex catchFish {\n    ask fish at_distance 10 {\n      do die;\n    }\n  }\n}\n\nexperiment FisheryExperiment type: gui {\n  output {\n    display \"Fishery\" type: opengl {\n      species fish color: rgb(0,255,0);\n      species boat color: rgb(255,0,0);\n    }\n  }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Now, I want to display that field during the simulation. Can you provide a code for that?",
        "answer": "mesh flow scale: 10 triangulation: true color: palette(reverse(brewer_colors(\"Blues\"))) transparency: 0.5 no_data:0.0 ;",
        "nickname": "z"
      },
      {
        "question": "Create a GAML code snippet that displays a Java2D chart (named chart_1) representing the distribution of the species `laborers` by states. The states include 'vacant,' 'manage_nursery,' 'assigned_nursery,' 'assigned_harvester,' 'assigned_planter,' and 'independent.' The chart should depict the count of laborers in each state where the 'com_identity' attribute is nil.",
        "answer": "display chart_1 type: java2D{\t\nchart \"Own laborer according to state\" type: series\n\t{\n\tlist<string> states <- [\"vacant\", \"manage_nursery\", \"assigned_nursery\", \"assigned_harvester\", \"assigned_planter\", \"independent\"];\n\tloop i over: states{\n\t\tdata i value: count(labour, each.state = i and each.com_identity=nil);\n\t}\n}\n}",
        "nickname": "z"
      },
      {
        "question": "Create an experiment that shows in the display the species iris which was created from a csv file (iris.csv).",
        "answer": "experiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}",
        "nickname": "julius"
      },
      {
        "question": "Write GAML code to create monitors that track the total count of 'Warned Independent Harvester' agents (assuming they are represented by the variable total_warned_CM) and the total number of trees in the simulation (assuming they are represented by the variable trees) during simulation. Label the monitors as 'Total Warned Independent Harvester' and 'Tree count' respectively.",
        "answer": "monitor \"Total Warned Independent Harvester\" value: total_warned_CM;\nmonitor \"Tree count\" value: length(trees);",
        "nickname": "z"
      },
      {
        "question": "Generate a 2D pie chart titled 'People Objectif' using data from a list of people objects. Each object has an 'objective' field (string) indicating their objective ('working' or 'resting'). Calculate the number of people in each category and represent them as separate slices in the pie chart.",
        "answer": "\nchart \"People Objectif\" type: pie\n{\n  data \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n  data \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\n}\n",
        "nickname": "Guest"
      },
      {
        "question": "create an experiment to showcase the different uses of pie charts. The data doesn't matter",
        "answer": "\nexperiment \"Different Pies\" type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false ;\t\n\t\t\n\t\tdisplay \"data_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Nice Ring Pie Chart\" type: pie style: ring background: # darkblue color: # lightgreen label_text_color: #red label_background_color: #lightgray axes: #red  title_font: font( 'Serif', 32, #italic)\n\t\t\ttick_font: font('Monospaced' , 14, #bold) label_font: font('Arial', 32 #bold) x_label: 'Nice Xlabel' y_label:\n\t\t\t'Nice Ylabel'\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 100 + cos(100 * cycle) * cycle * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_3Dpie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_3Dpie_chart\" type: pie style: 3d\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 2 * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_pie_chart\" type: pie style: exploded  series_label_position: \"none\" \n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] value: [[cycle, cycle + 1, 2], [cycle / 2, cycle * 2, 1], [cycle + 2, cycle - 2, cycle]] x_err_values: [3, 2, 10] y_err_values:\n\t\t\t\t[3, cycle, 2 * cycle]\n\t\t\t\t//\t\t\t\t\tcategoriesnames:[\"C1\",\"C2\",\"C3\"]\n\t\t\t\tcolor: [# black, # blue, # red];\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Generate GAML code to create a layout with a horizontal structure containing two vertical sections whereby, each vertical section should have two elements of equal size.",
        "answer": "layout horizontal([vertical([0::5000,1::5000])::5000,vertical([2::5000,3::5000])::5000]);",
        "nickname": "z"
      },
      {
        "question": "How can i add a depth to my geometry ? ",
        "answer": "geometry line3D <- line([{20,60}, {40,60}]);\n\ndraw line3D depth: 10 color: #red;\n\nexperiment depth type:gui{\noutput{\n  display view type:opengl{\n    graphics \"Lines\" {\n      draw line3D depth: 10 color: #red;\n    }\n  }\n }\n}",
        "nickname": "Arno "
      },
      {
        "question": "How can I add depth to a geometry in an aspect? ",
        "answer": "aspect base {\n  draw shape depth: height;\n}",
        "nickname": "Arno "
      },
      {
        "question": "Give me a model that initialises a grid from a JSON FIle.",
        "answer": "model json_loading   \n\nglobal {\n\tfile JsonFile <- json_file(\"../includes/cityIO.json\");\n    map<string, unknown> c <- JsonFile.contents;\n\n\tinit { \n\t\tlist<map<string, int>> cells <- c[\"grid\"];\n        loop mm over: cells {                 \n            cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n            cell.type <-int(mm[\"type\"]);\n        }\n\t}  \n} \n\ngrid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay cityMatrixView   type: 3d axes:false{\t\n\t\t\tspecies cityMatrix aspect:base;\t\t\t\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "How can i change the color of an agent in an aspect? ",
        "answer": "aspect base {\n  draw shape color: color;\n}",
        "nickname": "Arno "
      },
      {
        "question": "How do I generate a random number between 0 and 255 in Gama? ",
        "answer": "int my_number<-rnd(255);",
        "nickname": "Arno "
      },
      {
        "question": "How do I generate a random number between -100 and 100 in Gama? ",
        "answer": "int my_number<-rnd(-100,100);",
        "nickname": "Arno "
      },
      {
        "question": "Load a json file (cityIO.json) that comes with gama. ",
        "answer": "file JsonFile <- json_file(\"../includes/cityIO.json\");",
        "nickname": "julius"
      },
      {
        "question": "create a 2d display called example to show a 3d pie chart that will have 3 categories: A, B and C, respectively colored in grey, green and red. A category will have a value of 3, B of 10 and C of 100",
        "answer": "display \"example\" type: 2d {\n\tchart \"data_3Dpie_chart\" type: pie style: 3d\n\t{\n\t\tdata \"A\" value: 3 color: #grey;\n\t\tdata \"B\" value: 10 color: #green;\n\t\tdata \"C\" value: 100 color:#red;\n\t}\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a simulation environment to experiment with different color schemes and styling options for radar charts",
        "answer": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a model using a cellular automata to represent the Game of Life, the most famous example of cellular automata. Each cell will see if the number of living neighbours meets the condition to emerge or to live.",
        "answer": "model life\n\n//Declare the world as a torus or not torus environment\nglobal torus: torus_environment {\n\t//Size of the environment\n\tint environment_width <- 200 min: 10 max: 1000;\n\tint environment_height <- 200 min: 10 max: 1000;\n\tbool parallel <- true;\n\t//Declare as torus or not\n\tbool torus_environment <- true;\n\t//Density \n\tint density <- 25 min: 1 max: 99;\n\t//Conditions to live\n\tlist<int> living_conditions <- [2, 3];\n\t//Conditions to birth\n\tlist<int> birth_conditions <- [3];\n\t//Color for living cells\n\trgb livingcolor <- #white;\n\t//Color for dying cells\n\trgb dyingcolor <- #red;\n\t//Color for emerging cells\n\trgb emergingcolor <- #orange;\n\t//Color for dead cells\n\trgb deadcolor <- #black;\n\t//Shape of the environment\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\t\n\t//Initialization of the model by writing the description of the model in the console\n\tinit {\n\t\tdo description;\n\t}\n\t\n\t//Ask at each life_cell to evolve and update\n\treflex generation {\n\t\t// The computation is made in parallel\n\t\task life_cell parallel: parallel {\n\t\t\tdo evolve;\n\t\t}\n\t}\n\t//Write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t'Description. The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is the best-known example of a cellular automaton. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.  The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur: \\n\\t 1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. \\n\\t 2.Any live cell with more than three live neighbours dies, as if by overcrowding. \\n\\t 3.Any live cell with two or three live neighbours lives on to the next generation. \\n\\t 4.Any dead cell with exactly three live neighbours becomes a live cell. The initial pattern constitutes the seed of the system. The first(generation) is created by applying the above rules simultaneously to every cell in the seed�births and deaths happen simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before). The rules continue to be applied repeatedly to create further generations.';\n\t}\n\n}\n\n//Grid species representing a cellular automata\ngrid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false \nuse_neighbors_cache: false parallel: parallel{\n\t//Boolean to know if it is the new state of the cell\n\tbool new_state;\n\t//List of all the neighbours\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\t//Boolean  to know if it is a living or dead cell\n\tbool alive <- (rnd(100)) < density;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\t//Action to evolve the cell considering its neighbours\n\taction evolve {\n\t\t//Count the number of living neighbours of the cells\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\t//If the number of living respect the conditions, the cell is still alive\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\t//If the number of living meets the conditions, the cell go to born\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\t//Action to update the new state of the cell\n\treflex update {\n\t\talive <- new_state;\n\t}\n\n}\n\n\nexperiment \"Game of Life\" type: gui {\n\tparameter \"Run in parallel \" var: parallel category: 'Board';\n\tparameter 'Width:' var: environment_width category: 'Board';\n\tparameter 'Height:' var: environment_height category: 'Board';\n\tparameter 'Torus?:' var: torus_environment category: 'Board';\n\tparameter 'Initial density of live cells:' var: density category: 'Cells';\n\tparameter 'Numbers of live neighbours required to stay alive:' var: living_conditions category: 'Cells';\n\tparameter 'Numbers of live neighbours required to become alive:' var: birth_conditions category: 'Cells';\n\tparameter 'Color of live cells:' var: livingcolor category: 'Colors';\n\tparameter 'Color of dying cells:' var: dyingcolor category: 'Colors';\n\tparameter 'Color of emerging cells:' var: emergingcolor category: 'Colors';\n\tparameter 'Color of dead cells:' var: deadcolor category: 'Colors';\n\toutput {\n\t\tdisplay Life type: 3d axes:false antialias:false{\n\t\t\tgrid life_cell;\n\t\t}\n\n\t}\n\n}\n",
        "nickname": "julius"
      },
      {
        "question": "I would like to create a model where I have building with a specific width, height and width that are randomly placed in my scene. I want the building shape to change randomly at each iteration ",
        "answer": "model city\n\nglobal{\ninit { \n      create Building number:number_of_building{\n      \t     width <- (rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100)*50+10;\n\t\t\t depth <-\t(rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100*width)*10+10;\n\t\t\tshape <- box(width, width, depth) rotated_by rnd(360);\n\n\t\t}\n\t}  \n\n}\n\n\nspecies Building{\n\tfloat width;\n\tfloat height;\n\tfloat depth;\n\tint angle;\t\t\t\n\n\t\n\treflex shuffle{\n\t\t width <- (rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100)*50+10;\n\t\t depth <-\t(rnd(100)/100)*(rnd(100)/100)*(rnd(100)/100*width)*10+10;\n\t\t shape <- box(width, width, depth) rotated_by rnd(360);\n\t}\n\t\n\taspect base {\n\t\tdraw shape color:#white;\n\t}\n\t\n}\n\nexperiment DisplayTextured  type: gui {\noutput {\n\t display City type:3d{\n\t\tspecies Building aspect:base;\t\t\t\t\t\t\t\n\t}\n  }\n}",
        "nickname": "Arno "
      },
      {
        "question": "Demonstrate the application of radar charts in displaying complex data patterns and trends in a user-friendly graphical format.",
        "answer": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a specie called empty_building which is inherited from the specie building. It will have the attribute building_type that will be initialized with \"empty_building\" and a color which is grey defined by rgb(100,100,100)",
        "answer": "species empty_building parent: building{\n\tstring building_type <- \"empty_building\";\n\trgb color <- rgb(100,100,100);\n}",
        "nickname": "Léon"
      },
      {
        "question": "Generate the snippet of code that generate a chart that at each simulation step, display the value of y according to the value of x",
        "answer": "chart \"x and y\" type: xy\n{\n  data legend: \"x\" value:[x,y] line_visible: false color: #green;\n}",
        "nickname": "Guest"
      },
      {
        "question": "Develop a tutorial demonstrating the implementation of radar charts in a graphical interface for data analysis and visualization",
        "answer": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a grid cityMatrix from a json file,  with a width of 16 and height of 16. The color of each grid will depend on its type, each cell's border color is black, and the background of the cell will be black.",
        "answer": "grid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Create a reflex that occurs every day and that will set the boolean variable is_party_day true with a probability of 0.2 and the boolean is_evening_shopping_day at true with the probability of 0.4.",
        "answer": "reflex today_feeling when:every(1#day){\n    bool is_party_day <- flip(0.2);\n    bool is_evening_shopping_day <- flip(0.4);\n}",
        "nickname": "Léon"
      },
      {
        "question": "I have two lists of x and y values called serie_x and serie_y, create a chart to display them as (x,y) points",
        "answer": "chart \"serie_x and serie_y\" type: xy size: {1.0,0.5}{\n\tdata legend: \"x\" value:rows_list(matrix([serie_x,serie_y])) ;\n}\n\t\t\t",
        "nickname": "PasPatrick"
      },
      {
        "question": "How can I apply a texture to a shape? ",
        "answer": "file gamaRaster <- file('../images/Gama.jpg');\n\nspecies Geometry2D{  \n\n  geometry myGeometry;\n\t\n  aspect default {\n    draw myGeometry texture:gamaRaster.path;\n  }\n} ",
        "nickname": "Arno "
      },
      {
        "question": "For drawin the specie, create an aspect called base that draws a circle of radius build_len/15, the color is the color attribute of the specie, the border is black and placed at the location: location + offset",
        "answer": "aspect base {\n\tdraw circle(build_len/15) color: color border:#black at: location + offset;\n}",
        "nickname": "Léon"
      },
      {
        "question": "I have two variables, x and y that represent one data point and are updated every cycle. Create a chart that will display the evolution of that data point on an xy type of chart with green points and no lines. Call that series of values \"x\"",
        "answer": "//at each simulation step, display the value of y according to the value of x\nchart \"x and y\" type: xy size: {1.0,0.5} position: {0,0.5}{\n\tdata legend: \"x\" value:[x,y] line_visible: false color: #green;\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Generate a complete model that shows how to access and manipulate fields information. To demonstrate this, two agents are created. One agent increases the values in the field, another one decreases them.",
        "answer": "model AccessingFields\n\nglobal torus: true{\n\tgeometry shape <- square(2000);\n\tfield terrain <- field(300, 300);\n\n\tinit {\n\t\tcreate increaser with: [location::location];\n\t\tcreate decreaser with: [location::location];\n\t}\n\n\tspecies increaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] + 1.0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspecies decreaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] - 1.0;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Show\" {\n\tlist<rgb> palette <- brewer_colors(any(brewer_palettes(0)));\n\toutput {\n\t\tdisplay Field type: 3d {\n\t\t\tmesh terrain color: palette triangulation: true smooth: 4;\n\t\t}\n\n\t}\n\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Create a field named terrain with dimensions 300 by 300.",
        "answer": "field terrain <- field(300, 300);",
        "nickname": "julius"
      },
      {
        "question": "Create a model to showcase how to drag and drop an agent inside the simulation's world with the mouse.",
        "answer": "/**\n* Name: MouseDrag\n* \n* Demonstrates the usage of the mouse_drag events to move an agent using user\n* interactions. Drag events are triggered when the mouse is moving with the\n* mouse button down. Notice that move events are not triggered when the mouse\n* button is down.\n* \n* Author: breugnot\n* Tags: gui, event, mouse_move, mouse_drag, mouse_down, mouse_up\n*/\n\nmodel mouse_event\n\nglobal {\n\tgeometry shape <- square(20);\n\tDraggedAgent selected_agent <- nil;\n\tinit {\n\t\tcreate DraggedAgent with: (location: {10, 10});\n\t}\n\t\n\t/** Insert the global definitions, variables and actions here */\n\taction mouse_down {\n\t\task DraggedAgent {\n\t\t\tif( self covers #user_location) {\n\t\t\t\t// Selects the agent\n\t\t\t\tselected_agent <- self;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction mouse_up {\n\t\tif(selected_agent != nil) {\n\t\t\tselected_agent <- nil;\n\t\t}\n\t}\n\t\n\taction mouse_drag {\n\t\t// Makes the agent follow the mouse while the mouse button is down\n\t\tif(selected_agent != nil) {\n\t\t\task selected_agent {\n\t\t\t\tlocation <- #user_location;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies DraggedAgent {\n\tinit {\n\t\tshape <- circle(1);\n\t}\n\taspect default {\n\t\tdraw shape at: location;\n\t}\n}\n\nexperiment \"Mouse Drag\" type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\toutput {\n\t\tdisplay \"Mouse Drag [OPENGL]\" type:opengl {\n\t\t\tcamera #from_above locked:true;\n\t\t\tevent #mouse_down {ask simulation {do mouse_down;}}\n\t\t\tevent #mouse_up {ask simulation {do mouse_up;}}\n\t\t\tevent #mouse_drag {ask simulation {do mouse_drag;}}\n\t\t\t\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world color: #white border:#black;\n\t\t\t}\n\n\t\t\tspecies DraggedAgent aspect:default;\n\t\t}\n\t}\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Give me a model which shows how to use a confirm dialog box. ",
        "answer": "model Confirmdialog_example\n\nglobal {\n\tinit {\n\t\tbool  result <- user_confirm(\"Confirmation dialog box\",\"Do you want to confirm?\");\n\t\twrite sample(result);\n\t}\n}\n\nexperiment Confirmdialog_example type: gui ;",
        "nickname": "julius"
      },
      {
        "question": "show me how to have an agent that follow the user's mouse on the screen",
        "answer": "/**\n* Name: followmouse\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\nmodel followmouse\n\nglobal {\n\tinit {\n\t\tcreate dummy;\n\t}\n}\nspecies dummy {\n\tgeometry shape <- square(10);\n\treflex follow_mouse{\n\t\tlocation <- #user_location;\n\t}\n}\n\nexperiment follow {\n\toutput{\n\t\tdisplay main{\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "create a simulation where an agent of a species called dummy updates its location every cycle to be the same as the location of the user's mouse on the display. The agent's shape is going to be a square with a size of 10",
        "answer": "/**\n* Name: followmouse\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\nmodel followmouse\n\nglobal {\n\tinit {\n\t\tcreate dummy;\n\t}\n}\nspecies dummy {\n\tgeometry shape <- square(10);\n\treflex follow_mouse{\n\t\tlocation <- #user_location;\n\t}\n}\n\nexperiment follow {\n\toutput{\n\t\tdisplay main{\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Give me a code snippet that generate a chart that compute the percentage of agents being happy in the model at each step. The happiness is represented as a boolean value 'is_happy'. The variable number_of_people gives the total number of people in the model.",
        "answer": "chart \"Global happiness and similarity\" type: series\n{\n    data \"happy\" value:  (people count (each.is_happy) / number_of_people) * 100;\n}",
        "nickname": "Guest"
      },
      {
        "question": "Can I call a specific action when I click on the mouse on my screen? ",
        "answer": "// Define an action that will be called when the user click\n\naction mouse_down {\n  //Define what you want to do in your action\n}\n\n// In the display define an event layer\ndisplay view{\n  //event #mouse_down {ask simulation {do mouse_down;}}\n}",
        "nickname": "Arno "
      },
      {
        "question": "Give me a complete model that shows how to create agents, and save the agents's attributes (speed, size) inside a CSV File at a specific time step. The created agents can move and change size at each time step. ",
        "answer": "model SavetoCSV\n\nglobal {\n\tinit { \n\t\t//Create all the agents\n\t\tcreate bug number: 50;\n\t}\n\t//Save the agents bug when the cycle is equals to 100\n\treflex save_bug_attribute when: cycle = 100{\n\t\task bug {\n\t\t\t// save the values of the variables name, speed and size to the csv file; the rewrite facet is set to false to continue to write in the same file\n\t\t\tsave [name,speed, size] to: \"../results/bug.csv\" format:\"csv\" rewrite: false;\n\t\t\t// save all the attributes values of the bug agents in a file. The file is overwritten at every save\n\t\t\tsave bug to: \"../results/bug_agents.csv\" format:\"csv\" rewrite: true;\n\t\t}\n\t\t//Pause the model as the data are saved\n\t\tdo pause;\n\t}\n}\n\n//Species that will be saved\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Can I define a specific behaviour when I drag my mouse?",
        "answer": "// Define an action that will be called when the user drag the mouse\n\naction mouse_drag {\n  //Define what you want to do in your action\n}\n\n// In the display define an event layer\ndisplay view{\n  event #mouse_drag {ask simulation {do mouse_drag;}}\n}",
        "nickname": "Arno "
      },
      {
        "question": "Generate the definition of a grid representing a sugar plant. Each cell contains an initial value of sugar given by the attribute 'initialSugarValue'. Each sugar cell can hold a maximum given amount of sugar designated by the variable 'maxSugar'. At each step, the amount of sugar of each cell is incremented by a given value called 'sugarGrowthRate'. The size of the grid is 50x50. each cells have 4 neighbors.",
        "answer": "grid sugar_cell width: 50 height: 50 neighbors: 4 \n{ \n\t//Maximum sugar\n\tint maxSugar;\n\t//Sugar contained in the cell\n\tint sugar update: sugar + sugarGrowthRate max: maxSugar;\n}\t",
        "nickname": "Guest"
      },
      {
        "question": "How can I pause my simulation? ",
        "answer": "do pause;",
        "nickname": "Arno "
      },
      {
        "question": "Generate a model that stops when all the people agent are happy. ",
        "answer": "global {\n\tint nb_happy_people <- 0 update: people count each.is_happy ;\n\n\t// attributes and init of the global\n\treflex end_simulation when: nb_happy_people = length(people) {\n\t\tdo pause;\n\t}\n}\n\nspecies people {\n       bool is_happy;\n}",
        "nickname": "patrick"
      },
      {
        "question": "Generate a experiment that defines 3 parameters and a didplay of the people species (using the asp_circle aspect). These 3 parameters correspond to the 3 global variables: nb_people, rate_similar_wanted, and neighbours_distance.",
        "answer": "experiment Schelling1 type: gui {\n\tparameter \"nb of people\" var: nb_people;\n\tparameter \"rate similar wanted\" var: rate_similar_wanted min: 0.0 max: 1.0;\n\tparameter \"neighbours distance\" var: neighbours_distance step: 1.0;\n\t\n\toutput {\n\t\tdisplay people_display {\n\t\t\tspecies people aspect: asp_circle;\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Generate a GAML code snippet with the following specifications:\n\n\n1. Define a new species named `vehicle` that includes the skill `driving`.\n2. Assign to the species a random RGB color value.\n3. Inside the species, include an `init` block that initializes the following properties:\n  - `vehicle_length` as `1.9` meters (use the `#m` annotation for meters).\n  - `max_speed` as `100` km/h.\n  - `max_acceleration` as a floating-point number `3.5`.\n\n\n4. Add a reflex named `select_next_path` that is triggered when the condition `current_path` is `nil`.\n  - Within this reflex, add a comment to denote it should compute a cyclical path.\n  - Use the `compute_path` action within this reflex, specify the parameters `graph` with the value `road_network`, and `target` using the value `one_of(intersection)`.\n\n\n5. Create another reflex named `commute` which is triggered when `current_path` is not `nil`.\n  - The reflex should contain the action `drive`.\n\n\n6. Define an aspect named `base` for the visual representation of the species.\n  - The aspect should draw a triangle with a size of `5.0`.\n  - Specify the color of the triangle to be the previously defined random color.\n  - Indicate the triangle should be rotated by the `heading + 90` degrees.\n  - Outline the triangle with the color `#black`.\n\n\nEnsure the code includes the appropriate GAML syntax, proper formatting, and comments for clarity.\n",
        "answer": "species vehicle skills: [driving] {\n   rgb color <- rnd_color(255);\n   init {\n       vehicle_length <- 1.9 #m;\n       max_speed <- 100 #km / #h;\n       max_acceleration <- 3.5;\n   }\n\n\n   reflex select_next_path when: current_path = nil {\n       // A path that forms a cycle\n       do compute_path graph: road_network target: one_of(intersection);\n   }\n  \n   reflex commute when: current_path != nil {\n       do drive;\n   }\n   aspect base {\n       draw triangle(5.0) color: color rotate: heading + 90 border: #black;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Generate a GAML code snippet that defines a `species` with these characteristics:\n\n\n1. The species should be named `people` and contain the skill `pedestrian`.\n2. Incorporate a `schedules` facet that shuffles the order of `people`.\n3. Assign to the species a random RGB color value.\n4. Define a speed attribute as a `float` type with a value of 3 km/h.\n5. Include a boolean attribute `avoid_other` and set its initial value to `true`, which makes the pedestrian to avoid other pedestrians.\n6. Declare a `point` type variable named `current_target`.\n\n\nAdd a `reflex` named `move` that is activated when `current_target` is not `nil` and has the following behavior:\n\n\n- Use an `if` statement to check if there is an obstacle (`nb_obstacles > 0`). If true:\n - Invoke the action `walk_to` with the `target` facet set to `current_target` and `bounds` facet set to `free_space`.\n- If there are no obstacles:\n - Call the action `walk_to` with `current_target` as the target without any bounds.\n- Add another condition within the reflex to check if the distance to the `current_target` is less than `0.5`. If the condition is met:\n - The individual should perform the `die` action.\n\n\nDefine an `aspect` named `default` for visual representation that should:\n\n\n- Draw a `triangle` with a size determined by the variable `shoulder_length`.\n- Set the `color` of the triangle to the previously defined random color variable.\n- Include a rotation based on the `heading + 90.0` degrees.\n\n\nEnsure that proper GAML syntax is used and include comments for better clarity where applicable.\n",
        "answer": "species people skills: [pedestrian] schedules: shuffle(people) {\n   rgb color <- rnd_color(255);\n   float speed <- 3 #km/#h;\n   bool avoid_other <- true;\n   point current_target ;\n   reflex move when: current_target != nil{\n       if (nb_obstacles > 0) {\n           do walk_to target: current_target bounds: free_space;\n       } else {\n           do walk_to target: current_target;\n       }\n       if (self distance_to current_target < 0.5) {\n           do die;\n       }\n   }\n   aspect default {\n       draw triangle(shoulder_length) color: color rotate: heading + 90.0;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n1. **Module Name**\n  - Set the model name to `json_loading`.\n\n\n2. **Global Variable Definitions**\n  - Introduce a `global` species with a variable `JsonFile` that holds the JSON file loaded from a relative path \"../includes/cityIO.json\".\n\n\n3. **Initialization Procedure**\n  - In the `init` block within the `global` species scope, parse the `grid` data from the JSON file contents and iterate over each cell.\n  - For each cell in the grid, instantiate a `cityMatrix` grid element at the coordinates specified by `x` and `y` values in the current cell.\n  - Assign the `type` of each `cityMatrix` cell according to the `type` value specified in the cell data.\n\n\n4. **Grid Definition**\n  - Define a two-dimensional grid named `cityMatrix` with a width and height of 16.\n  - Give each cell in the grid an `rgb` color attribute initialized to black and an integer `type`.\n  - Under the `aspect base`, set the cells to draw shapes colored based on their `type` times a multiplier (e.g., 30), with a black border.\n\n\n5. **Experiment Setup**\n  - Design an experiment named `Display` with the type set to `gui`.\n  - Configure the output to display a `cityMatrixView` in 3D without axes.\n  - Within the display, set the species to `cityMatrix` and the aspect to `base`.\n\n\nEnsure that the code is well-formatted and adheres to GAML conventions for clarity and maintainability.\n",
        "answer": "model json_loading  \n\n\nglobal {\n   file JsonFile <- json_file(\"../includes/cityIO.json\");\n   map<string, unknown> c <- JsonFile.contents;\n\n\n   init {\n       list<map<string, int>> cells <- c[\"grid\"];\n       loop mm over: cells {                \n           cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n           cell.type <-int(mm[\"type\"]);\n       }\n   } \n}\n\n\ngrid cityMatrix width:16  height:16{\n   rgb color <- #black;\n   int type;\n   aspect base{   \n           draw shape color:rgb(type*30) border:#black ;\n   }\n}\n\n\nexperiment Display  type: gui {\n   output {\n       display cityMatrixView   type: 3d axes:false{  \n           species cityMatrix aspect:base;        \n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a GAML script that defines a 16x16 grid named `cityMatrix`. Each cell in the grid should be characterized by two properties: `color` and `type`. Follow these specifications:\n\n\n1. Initialize a color property using RGB, with a default value corresponding to black.\n\n\n2. Create an integer type variable called `type` but leave it uninitialized.\n\n\n3. Define an `aspect` named `base` for the visualization of the cells. Within this aspect:\n\n\n  a. Implement a drawing function for the cells.\n \n  b. The color of each shape should vary depending on the `type` property. Use the `type` value multiplied by 30 to set the RGB color component.\n \n  c. Outline each shape with a black border.\n",
        "answer": "grid cityMatrix width:16  height:16{\n   rgb color <- #black;\n   int type;\n   aspect base{   \n           draw shape color:rgb(type*30) border:#black ;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a GAML (GAma Modeling Language) code snippet that defines a species with the following characteristics and behaviors:\n\n\n- Name the species `cell`.\n- Equip the species with the skill `moving3D` to enable three-dimensional movement.\n- Define an `rgb color` attribute to store the color of the cell.\n- Include a `list<cell>` type attribute named `neighbors` to hold nearby cells.\n- Add an `int` type attribute named `offset`.\n- Incorporate a `reflex` named `move` that allows the cell to perform a wandering action using the `do wander;` command.\n- Include a `reflex` named `compute_neighbors` where each cell evaluates its surroundings and updates its `neighbors` list with cells that are within a distance of less than 10 units to itself.\n- Define an `aspect` named `default` that:\n - Draws the cell as a small sphere (`environment_size * 0.01`) colored orange.\n - Iterates over the `neighbors` list and for each neighbor, draws a line between the cell’s location and each neighbor's location.\n\n\nEnsure that the `aspect` visually represents the cells and their connections within the environment accurately.",
        "answer": "species cell skills: [moving3D] {\n   rgb color;\n   list<cell> neighbors;\n   int offset;\n\n\n   reflex move {\n       do wander;\n   }\n\n\n   reflex compute_neighbors {\n       neighbors <- cell select ((each distance_to self) < 10);\n   }\n\n\n   aspect default {\n       draw sphere(environment_size * 0.01) color: #orange;\n       loop pp over: neighbors {\n           draw line([self.location, pp.location]);\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Structure Overview:**\n- Design a model titled `quick_user_command_model`.\n- The model should initialize with a specific number of agents belonging to a species named `my_species`.\n\n\n**Global Initialization Requirements:**\n- In the global `init` block, ensure the model creates a predefined number of `my_species` agents.\n\n\n**Species Definition and Behavior:**\n- Define a species `my_species` with the following characteristics:\n - The species should respond to a user command, preferably one related to an experiment's runtime action (e.g., `die` when a certain command is issued).\n - Characterize `my_species` with a basic aspect that visualizes each agent with a simple geometric shape and color.\n\n\n**Aspect Visualization Details:**\n- The aspect labeled `base` should include:\n - The ability to draw a shape, such as a circle, with a specified size.\n - An attribute to set the color of the shape to a user-defined hexadecimal color code.\n\n\n**Experiment Configuration:**\n- Set up an experiment with the identifier `expe` of type `gui`.\n- This experiment should feature output configurations that include:\n - A display component labeled `my_display`.\n - The display should visualize the `my_species` agents using the `base` aspect defined earlier in the species block.\n\n\n**User Interactivity:**\n- Include user interactivity within the experiment that allows for the modification of `my_species` behavior during runtime through specific commands.",
        "answer": "model quick_user_command_model\n\n\nglobal {\n   init {\n       create my_species number:10;\n   }\n}\n\n\nspecies my_species {\n   user_command cmd_inside_experiment action:die;\n   aspect base {\n       draw circle(1) color:#blue;\n   }\n}\n\n\nexperiment expe type:gui {\n   output {\n       display my_display {\n           species my_species aspect:base;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a species called \"animal\" within a simulation environment. Each animal will have a red color by default, move at a speed of 1.0, and possess varying attributes like metabolism (random between 1 and maxMetabolism), vision range (random between 1 and maxRange), and lifespan (random within a defined range). Animals also have a fixed size of 0.5 and manage their energy through \"sugar\" reserves, which decrease with each step based on their metabolism. They keep track of their age, capped at their maximum lifespan, and occupy specific locations within the simulation grid represented by \"sugar_cells.\"",
        "answer": "species animal {\n\t//Color of the animal\n\trgb color  <- #red;\n\t//Speed of the animal\n\tfloat speed  <- 1.0;\n\t//Metabolism of the animal\n\tint metabolism  min: 1 <- rnd(maxMetabolism);\n\t//Perception range of the animal\n\tint vision  min: 1 <- rnd(maxRange);\n\t//Maximal age of the animal\n\tint maxAge  min: minDeathAge max: maxDeathAge <- rnd (maxDeathAge - minDeathAge) + minDeathAge;\n\t//Size of the animal\n\tfloat size  <- 0.5;\n\t//Sugar of the animal\n\tint sugar min: 0 <- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;\n\t//Age of the animal\n\tint age max: maxAge <- 0 update: int(age + step);\n\t//Place of the animal\n\tsugar_cell place;\n} ",
        "nickname": "Guest"
      },
      {
        "question": "Can I draw my agent as a sphere of radius 1",
        "answer": "draw sphere(1);",
        "nickname": "Arno "
      },
      {
        "question": "How to draw my agent as a circle of radius 1",
        "answer": "draw circle(1);",
        "nickname": "Arno "
      },
      {
        "question": "Create a complete model showing an agent or a group of agent navigating in space using his field of vision (perception angle, distance), to avoid barriers.",
        "answer": "model fieldofvision\n\nglobal {\n\t//number of obstacles\n\tint nb_obstacles <- 20 parameter: true;\n\t\n\t//perception distance\n\tfloat perception_distance <- 40.0 parameter: true;\n\t\n\t//precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation\n\tint precision <- 600 parameter: true;\n\t\n\t//space where the agent can move.\n\tgeometry free_space <- copy(shape);\n\tinit {\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tshape <- rectangle(2+rnd(20), 2+rnd(20));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people  {\n\t\t\tlocation <- any_location_in(free_space);\n\t\t}\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nspecies people skills: [moving]{\n\t//zone of perception\n\tgeometry perceived_area;\n\t\n\t//the target it wants to reach\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\tif (perceived_area = nil) or (perceived_area.area < 2.0) {\n\t\t\t\t//if the agent has no target and if the perceived area is empty (or too small), it moves randomly inside the free_space\n\t\t\t\tdo wander bounds: free_space;\n\t\t\t} else {\n\t\t\t\t//otherwise, it computes a new target inside the perceived_area .\n\t\t\t\ttarget <- any_location_in(perceived_area);\n\t\t\t}\n\t\t} else {\n\t\t\t//if it has a target, it moves towards this target\n\t\t\tdo goto target: target;\n\t\t\t\n\t\t\t//if it reaches its target, it sets it to nil (to choose a new target)\n\t\t\tif (location = target)  {\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\n\t}\n\t//computation of the perceived area\n\treflex update_perception {\n\t\t//the agent perceived a cone (with an amplitude of 60°) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); \n\t\t\n\t\t//if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,precision);\n\n\t\t}\n\t}\n\t\n\taspect body {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t}\n\taspect perception {\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t\tdraw circle(1) at: target color: #magenta;\n\t\t}\n\t}\n}\n\nexperiment fieldofvision type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tdisplay view{\n\t\t\tspecies obstacle;\n\t\t\tspecies people aspect: perception transparency: 0.5;\n\t\t\tspecies people aspect: body;\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Specification:**\n- Create a model with the identifier `CSVfileloading`.\n- The central function of this model is to load agent data from a CSV file.\n\n\n**CSV File Agent Creation:**\n- In the `init` block of the `global` species, instruct the model to:\n - Generate `iris` agents by importing data from a CSV file named `iris.csv`. Assume this file is located within a `includes` directory at the parent level of the current project.\n - Utilize the CSV file header to automatically map columns to agent attributes.\n - Directly assign the agent's attributes using the header values, converting them to the correct data type (e.g., `float` for numeric values and `string` for textual values).\n\n\n**Species Attributes and Initialization:**\n- Define a species `iris` with attributes:\n - Numeric attributes: `sepal_length`, `sepal_width`, `petal_length`, `petal_width`.\n - Categorical attribute: `type`.\n - Visualization attribute: `color` of type `rgb`.\n\n\n- For initial species attributes:\n - Assign color values based on the `type` attribute using a conditional statement. For instance, if `type` equals `Iris-setosa`, set the color to blue, otherwise, if `type` equals `Iris-virginica`, set the color to red; default to yellow for all other types.\n\n\n**Visualization Aspect:**\n- Define an aspect named `default` for the `iris` species that:\n - Draws a circle with the size based on the `petal_width`.\n - Colors the circle with the `color` attribute defined in the `iris` species.\n\n\n**Experiment Configuration:**\n- Create an experiment titled `main` with a graphical user interface (GUI).\n- For the experiment`s output:\n - Set up a display titled `map`.\n - Ensure the display visualizes the `iris` species with the previously defined `default` aspect.\n\n\n**Additional Notes:**\n- Include comments in the global `init` block to clarify the purpose of the `header` facet when loading from the CSV file and the impact of setting it to true or false.",
        "answer": "model CSVfileloading\n\n\nglobal {\n  \n   init {\n       //create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files:\n       //we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n       create iris from:csv_file( \"../includes/iris.csv\",true) with:\n           [sepal_length::float(get(\"sepallength\")),\n               sepal_width::float(get(\"sepalwidth\")),\n               petal_length::float(get(\"petallength\")),\n               petal_width::float(get(\"petalwidth\")),\n               type::string(get(\"type\"))\n           ]; \n   }\n}\n\n\nspecies iris {\n   float sepal_length;\n   float sepal_width;\n   float petal_length;\n   float petal_width;\n   string type;\n   rgb color ;\n  \n   init {\n       color <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n   }\n  \n   aspect default {\n       draw circle(petal_width) color: color;\n   }\n}\n\n\nexperiment main type: gui{\n   output {\n       display map {\n           species iris;\n       }\n   }\n  \n}\n",
        "nickname": "Tu"
      },
      {
        "question": "How can I instantiate agents from a csv file where each line of the csv represent an agent? ",
        "answer": "// Define the path to your csv file\ncreate myAgent from:csv_file(\"pathToYourFile/file.csv\");",
        "nickname": "Arno "
      },
      {
        "question": "Create a complete model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agent",
        "answer": "model Grid\n\nglobal {\n\t/*2 algorithms for the shortest path computation on a grid with weights:\n\t*      - A* : default algorithm: An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tfile dem <- file(\"../includes/vulcano_50.asc\");\n\tgeometry shape <- envelope(dem);\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tmap<cell,float> cell_weights;\n\n\tinit {    \n\t\task cell {grid_value <- grid_value * 5;}  \n\t\tfloat max_val <- cell max_of (each.grid_value);\n\t\task cell {\n\t\t\tfloat val <- 255 * (1 - grid_value / max_val);\n\t\t\tcolor <- rgb(val, val,val);\n\t\t}\n\t\tcell_weights <- cell as_map (each::each.grid_value);\n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell file: dem neighbors: neighborhood_type optimizer: algorithm {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- 1.0;\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t\tif (current_path != nil) {\n\t\t\tdraw current_path.shape color: #red;\n\t\t}\n\t}\n\t\n\treflex move when: location != target{\n\t\t//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\n\t\t//followed by the agent\n\t\t//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\n\t\tdo goto (on:cell_weights, target:target, speed:speed, recompute_path: false);\n\t\t\n\t\t//As a side note, it is also possible to use the path_between operator and follow action with a grid\n\t\t//Add a my_path attribute of type path to the people species\n\t\t//if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}\n\t\t//do follow (path: my_path);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model that illustrates the use of the wander action of the moving Skill on a graph,  the probability to choose a road is given by a map (road::probability). Each road segment is constructed or defined from a line shape.",
        "answer": "model WanderonGraph\n\nglobal {\n\t\n\tgraph network;\n\t\n\t//map that gives the probability to choose a road\n\tmap<road,float> proba_use_road;\n\t\n\tinit {\n\t\tcreate road with: [shape::line([{10,10}, {40,10}])];\n\t\tcreate road with: [shape::line([{40,10}, {40,40}])];\n\t\tcreate road with: [shape::line([{40,10}, {80,10}])];\n\t\tcreate road with: [shape::line([{80,10}, {80,40}])];\n\t\tcreate road with: [shape::line([{40,40}, {80,40}])];\n\t\tcreate road with: [shape::line([{80,40}, {80,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {10,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {50,50}])];\n\t\tcreate road with: [shape::line([{50,50}, {10,80}])];\n\t\tcreate road with: [shape::line([{10,80}, {10,10}])];\n\t\t\n\t\t\n\t\tcreate people number: 50 with: [location::any_location_in(one_of(road))];\n\t\t\n\t\t//directed graph build from the road agents\n\t\tnetwork <- directed(as_edge_graph(road));\n\t\t\n\t\t//the map of probability to choose a road is build from the proba_use attribute of roads\n\t\tproba_use_road <- road as_map (each::each.proba_use);\n\t}\n}\n\nspecies road {\n\t// probability for a agent to choose this road\n\tfloat proba_use <- rnd(0.1, 1.0);\n\t\n\taspect default {\n\t\tdraw shape +(proba_use/2.0)  color: #gray end_arrow: 2.0;\n\t}\n}\n\nspecies people skills: [moving]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw circle(1.0) color:color border: #black;\n\t}\n\t\n\treflex move {\n\t\t// move randomly on the network, using proba_use_road to define the probability to choose a road.\n\t\tdo wander on: network proba_edges: proba_use_road ;\n\t}\n}\n\nexperiment WanderonGraph type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tdisplay map type:2d{\n\t\t\tspecies road;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "the GAML code for a waste bin agent",
        "answer": "species waste_bin {\n    float capacity;\n    float current_level;\n    point location;\n    \n    reflex update_level {\n        // Code to update the current level of waste in the bin\n    }\n    \n    reflex request_collection when: current_level > 0.8 * capacity {\n        // Code to request waste collection\n    }\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "How can I instantiate agents from a csv file where each line of the csv represent an agent and the value of n the first column name col1 of the csv to initiate an attribute1 of my species? ",
        "answer": "create myAgent from:csv_file(\"pathToYourFile/file.csv\") with:[attribute1::float(get(\"col1\"))];\n\nspecies myAgent{\n  float attribute1;\n}",
        "nickname": "Arno "
      },
      {
        "question": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Name Definition:**\n- Start by defining a model called `import_csv`.\n\n\n**Global Block Specifications:**\n- Declare a file variable to read from a CSV file named `test.csv`, assuming it's located in an `includes` subdirectory relative to the GAML file.\n\n\n**Initialization Steps:**\n- Within the block `init` of `global` species section:\n - Read and store the CSV file contents into a GAML matrix to represent the grid data.\n - Iterate over a custom grid, accessing each cell and:\n   - Assign cell values as floats from the corresponding entries in the matrix.\n   - Optionally, output the values to the console for verification.\n\n\n**Grid Configuration and Reflexes:**\n- Define a grid named `my_gama_grid` with specified dimensions (width and height).\n- Within this grid, create a reflex called `update_color` to:\n - Print the current cell’s value for debugging purposes.\n - Change the cell’s color based on its value using a conditional statement (e.g., if the value equals 1, color it blue, otherwise color it white).\n\n\n**Experiment and Output Settings:**\n- Set up an experiment called `main` of the `gui` type.\n- Configure the experiment`s output:\n - Display a visualization that shows `my_gama_grid`.\n - Ensure that the visualization updates to reflect changes in the grid, demonstrating the interaction between the cell values and their colors.",
        "answer": "model import_csv\n\n\nglobal {\n   file my_csv_file <- csv_file(\"../includes/test.csv\",\",\");\n   init {\n       matrix data <- matrix(my_csv_file);\n       ask my_gama_grid {\n           grid_value <- float(data[grid_x,grid_y]);\n           write data[grid_x,grid_y];\n       }\n   }\n}\n\n\ngrid my_gama_grid width: 11 height: 8 {\n   reflex update_color {\n       write grid_value;\n       color <- (grid_value = 1) ? #blue : #white;\n   }\n}\n\n\nexperiment main type: gui{\n   output {\n       display display_grid {\n           grid my_gama_grid;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model to show the movement on a graph created by polygons. The model will create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. All of the agents will use this graph to go to the same targeted location.",
        "answer": "model polygon\n\nglobal {\n\t//Import of the shapefile containing the different polygons\n\tfile shape_file_in <- file('../includes/gis/squareHole.shp') ;\n\tgraph the_graph;\n\t\n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tinit {    \n\t\tcreate object from: shape_file_in ;\n\t\tobject the_object <- first(object);\n\t\t\n\t\t//triangulation of the object to get the different triangles of the polygons\n\t\tlist<geometry> triangles <- list(triangulate(the_object, 0.01));\n\t\t\n\t\tloop trig over: triangles {\n\t\t\tcreate triangle_obj {\n\t\t\t\tshape <- trig;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//creation of a list of skeleton from the object \n\t\tlist<geometry> skeletons <- list(skeletonize(the_object, 0.01));\n\t\t\n\t\t//Split of the skeletons list according to their intersection points\n\t\tlist<geometry> skeletons_split  <- split_lines(skeletons);\n\t\tloop sk over: skeletons_split {\n\t\t\tcreate skeleton {\n\t\t\t\tshape <- sk;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Creation of the graph using the edges resulting of the splitted skeleton\n\t\t the_graph <- as_edge_graph(skeleton);\n\t\t \n\t\t \n\t\tcreate goal  {\n\t\t\t location <- any_location_in (one_of(skeleton)); \n\t\t}\n\t\tcreate people number: 100 {\n\t\t\t target <- one_of (goal) ; \n\t\t\t location <- any_location_in (one_of(skeleton));\n\t\t} \n\t}\n}\n\nspecies object  {\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}\n\nspecies triangle_obj  {\n\trgb color <- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));\n\taspect default {\n\t\tdraw shape color: color ; \n\t}\n}\n\nspecies skeleton  {\n\taspect default {\n\t\tdraw shape + 0.2 color: #red ;\n\t}\n}\n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(3) color:#red;\n\t}\n}\n\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\treflex goto {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n\taspect default {\n\t\tdraw circle(3) color: #green;\n\t}\n}\n\nexperiment goto_polygon type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies object aspect: default ;\n\t\t\tspecies triangle_obj aspect: default ;\n\t\t\tspecies skeleton aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Creating a GAML code for an enhanced backtracking search algorithm to optimize waste collection routes involves several steps. The algorithm would typically be used to determine the most efficient paths for waste collection vehicles to take, considering factors like the shortest travel distance, the least amount of time, or the lowest fuel consumption.",
        "answer": "global {\n  float threshold = 0.75; // Threshold for bin fullness to trigger collection\n  list<bin> bins; // List of all waste bins\n  list<vehicle> vehicles; // List of all collection vehicles\n}\n\nspecies bin {\n  float fullness <- 0; // Current fullness level\n  point location; // Geographic location of the bin\n  \n  reflex check_fullness {\n    if (fullness > threshold) {\n      // Code to mark bin for collection\n    }\n  }\n}\n\nspecies vehicle {\n  path current_route; // Current collection route\n  float capacity; // Vehicle capacity\n  float load <- 0; // Current load\n  \n  reflex plan_route {\n    // Code to plan the collection route using the backtracking search algorithm\n  }\n  \n  reflex collect_waste {\n    // Code to collect waste from bins\n  }\n}\n\nexperiment WasteCollection type: gui {\n  // Code to set up the simulation environment\n}\n",
        "nickname": "Patrick"
      },
      {
        "question": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Creation and Global Scope:**\n- Begin by defining a model named 'URLImageImport'.\n- Within the global scope, outline the purpose and structure of the model, which includes importing an image, manipulating it, and saving the result.\n\n\n**Auxiliary Function Definition:**\n- Introduce a utility function, say `essai`, which accepts an integer parameter and returns a modified value (in the example, the function always returns 100, but you can specify the desired operation). For clarity, provide a concise comment on the essence of the function.\n\n\n**External Image Import and Geometry Extraction:**\n- Declare an image file loaded from an external URL, providing the exact address as shown in the example (or specify any desired image URL for the task).\n- Extract and store a geometry from the image's envelope to demonstrate image handling capabilities in GAML.\n\n\n**Image Processing and Copying:**\n- Process the original image data by performing a `shuffle` operation on its contents. Outline the expected change of the data from this shuffle (e.g., pixel positions shuffled).\n- Construct an auxiliary function call to demonstrate how user-defined functions can interact with data, such as passing a value and storing the result in a variable.\n\n\n**Local Image File Creation and Initialization:**\n- Direct the creation of an image file in the local file system using the modified matrix data. Specify the path (e.g., \"../images/local_copy.png\") and the data source (shuffled image contents).\n- During the model's initialization phase (`init`), instruct the modified image file to be saved locally, providing the steps to persist the processed image data on the disk.\n\n\n**Experiment Design and Output Visualization:**\n- Outline an experiment named 'urlImage' that is intended for visualization of the transformation made to the image data.\n- In the experiment's output block:\n - Configure a display named 'display' with a white background.\n - Include instructions to display both the original image (`im`) and the locally saved copy (`copy`) within the display. Mention the element properties (e.g., size, position) if necessary for precise placement.\n\n\n**Additional Notes:**\n- Embed comments within the script to detail each step, particularly when dealing with GAML-specific functions such as `image_file`, `geometry`, `shuffle`, and `save`. This should guide the code creation process clearly.",
        "answer": "model URLImageImport\n\n\nglobal {\n  \n   int essai(int a) {\n       return 100;\n   }\n  \n   image_file im <- image_file(\"https://raw.githubusercontent.com/wiki/gama-platform/gama/resources/images/general/GamaPlatform.png\");\n   geometry shape <- envelope(im);\n   // We modify a bit the image\n   matrix<int> shuffle <- shuffle(im.contents);\n   int c <- essai(100);\n   // We create a file with the new contents\n   image_file copy <- image_file(\"../images/local_copy.png\", shuffle);\n   init {\n       // And save it\n       save copy;\n   }\n\n\n}\n\n\nexperiment urlImage {\n   output {\n       display 'display' background: #white {\n           image  copy;\n           image im ;\n       }\n\n\n   }\n\n\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Generate a model composed of an empty global block, a speciel animal and a grid of 30 by 30 plot cells. Plots have a, attribute state (type string).",
        "answer": "global { }\n\ngrid plot height: 30 width: 30 {\n\tstring state;\n}\n\nspecies animal {  }",
        "nickname": "patrick"
      },
      {
        "question": "Create a GAML code snippet that configures a new species with the following attributes, reflexes, and visual aspects:\n\n\n- Name the species `people`.\n- Assign the skill `moving` to enable basic movement capabilities.\n- Declare a boolean attribute `is_infected` with an initial value of `false`.\n- Create a `point` type attribute named `target` that will represent the location this person is moving towards.\n- Introduce an `int` type attribute called `staying_counter` that counts the number of cycles a person has stayed in one location.\n- Define a `reflex` named `stay` that activates when the `target` is `nil`. Within this reflex:\n - Increment `staying_counter` by 1 every cycle.\n - Use a probabilistic function `flip(staying_counter / staying_coeff)` to determine when to move, assigning a new target location selected from any of the buildings (`one_of(building)`).\n- Implement another `reflex` named `move` that triggers when `target` is not `nil` and should:\n - Command the person to go to the `target` via the `road_network`.\n - Reset `target` to `nil` and `staying_counter` to 0 once the `target` location is reached.\n- Add a `reflex` named `infect` that is executed when `is_infected` is true. It should:\n - Affect nearby `people` within a certain `infection_distance`.\n - Use a `flip(proba_infection)` function to probabilistically infect others.\n- Incorporate an `aspect` with the name `default` to visually represent the people in two-dimensional space by:\n - Drawing a circle of size 5 where the color is red if `is_infected` is true, and green otherwise.\n- Finally, create an `aspect` called `sphere3D` for three-dimensional visual representation where:\n - Each person is drawn as a sphere of radius 3, elevated above the ground by 3 units (`location.z + 3`).\n - The color of the sphere should also indicate the infection status, red for infected and green for not infected.\n\n\nEnsure that the snippet reflects the behavior and visual representation of the people, considering their infection status and movement within a modeled environment.\n",
        "answer": "species people skills:[moving]{    \n   bool is_infected <- false;\n   point target;\n   int staying_counter;\n   reflex stay when: target = nil {\n       staying_counter <- staying_counter + 1;\n       if flip(staying_counter / staying_coeff) {\n           target <- any_location_in (one_of(building));\n       }\n   }\n      \n   reflex move when: target != nil{\n       do goto target:target on: road_network;\n       if (location = target) {\n           target <- nil;\n           staying_counter <- 0;\n       }\n   }\n   reflex infect when: is_infected{\n       ask people at_distance infection_distance {\n           if flip(proba_infection) {\n               is_infected <- true;\n           }\n       }\n   }\n   aspect default{\n       draw circle(5) color:is_infected ? #red : #green;\n   }\n   aspect sphere3D{\n       draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model showing how to represent a flooding system with dykes and buildings. It uses a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.",
        "answer": "model hydro\n\nglobal {\n\t\n   //Shapefile for the river\n   file river_shapefile <- file(\"../includes/RedRiver.shp\");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file(\"../includes/Dykes.shp\");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file(\"../includes/Building.shp\");\n   \n   //Data elevation file\n   file dem_file <- file(\"../includes/mnt50.asc\");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n   \t //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n      \talready <- false;\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle  {\n   \t  //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n      \t//If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t//The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t//Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t//We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n   \t //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n   //layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart \"Pressure on Dykes\" type: series legend_font: font(\"Helvetica\", 18)  label_font: font(\"Helvetica\", 20, #bold)  title_font: font(\"Helvetica\", 24, #bold){\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}",
        "nickname": "julius"
      },
      {
        "question": "Generate an experiment displaying in a monitor the global variable nb_happy_people;",
        "answer": "experiment Schelling1 type: gui {\n\n\toutput {\n\t\t// other displays\n\n\t\tmonitor \"nb of happy people\" value: nb_happy_people;\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Load a river shapefile (RedRiver.shp) from the includes folder.",
        "answer": "file river_shapefile <- file(\"../includes/RedRiver.shp\");",
        "nickname": "julius"
      },
      {
        "question": "Develop a GAML code snippet that configures a grid representing vegetation cells. Detail the grid's properties and the internal attributes of the cells as follows:\n\n\n- Define the grid with the name `vegetation_cell` and set its size to a width of 50 and a height of 50 cells. Specify that each cell should consider 4 neighbors.\n- Inside the `vegetation_cell` species, declare a constant `float` variable `max_food` with a value of `1.0`.\n- Generate an initial `float` variable `food_prod` to represent food production, assigning it a random value up to `0.01`.\n- Establish a `float` variable `food`, representing the amount of food available in the vegetation cell, with a random initial value up to `1.0`. Ensure that this value cannot exceed `max_food` and is set to increment by `food_prod` at every update.\n- Create an `rgb` type variable `color` that reflects the food availability in the cell. The red and blue components of the RGB color should inversely correlate with the `food` variable (i.e., lower food leads to higher red and blue values), while the green component remains constant at `255`. Update this color to reflect changes in the food variable dynamically.\n- Define a list of `vegetation_cell` type named `neighbors2`. This list should be populated with neighboring cells at a distance of 2 grid steps from the current cell.\n\n\nThis snippet should allow the modeling of a dynamic grid in which food production and availability alter the appearance of each cell, and neighboring relationships are established for further interactions in the simulation.\n",
        "answer": "grid vegetation_cell width: 50 height: 50 neighbors: 4 {\n   float max_food <- 1.0;\n   float food_prod <- rnd(0.01);\n   float food <- rnd(1.0) max: max_food update: food + food_prod;\n   rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n   list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Generate an experiment displaying a chart in a new display called display_chart to follow the evolution of the number of happy people, stored in the nb_happy_people global variable.\n",
        "answer": "experiment main_xp type: gui {\n\t// parameter definition\n\t\n\toutput {\n\t\t// display monitor\n\t\tdisplay chart type:series {\n\t\t\tchart \"evolution of the number of happy people\" type: series{\n\t\t\t\tdata \"nb of happy people\" value: nb_happy_people color: #green;\n\t\t\t}\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Create a specie RandomGuy that has attributes rouge, vert, bleu which is a random number between 0 and 255, a function that returns its location, a reflex that uses the function wander from the skill moving, an action goTo that go to a new location, and for drawing it in the display, create an aspect called base that draw it a cricle of color defined by the attributes rouge, vert, bleu.",
        "answer": "species RandomGuy skills:[moving] {\n\t\n\n\tint rouge <- rnd(0,255);\n\tint bleu <- rnd(0,255);\n\tint vert <- rnd(0,255);\n\n\tpoint get_location {\n\t\treturn location;\n\t}\n\n    reflex move {\n        do wander;\n    }\n    \n    \n\t\n\taction goTo(point new_loc) {\n\t\tlocation <- new_loc;\n\t}\n\t\n    aspect base {\n    \tdraw circle(1) color:rgb(rouge,bleu,vert);\n    }\n    \n}",
        "nickname": "Léon"
      },
      {
        "question": "Build a GAML code snippet that constructs a species named `prey` with the following characteristics and rules:\n\n\n- Begin by setting up the `prey` species with a base size initialized to `1.0` and an assigned color of blue (`#blue`).\n- Declare a `float` attribute `max_energy`, which holds the maximum energy level for the prey, drawing its value from a global variable `prey_max_energy`.\n- Introduce a `float` attribute `max_transfer` representing the maximum amount of energy that can be transferred from food per time step, linked to the variable `prey_max_transfer`.\n- Define a `float` attribute `energy_consum` that specifies the rate of energy consumption by the prey, sourced from a variable `prey_energy_consum`.\n- Assign to the `prey` a home cell from the `vegetation_cell` grid using `one_of(vegetation_cell)` and store it in a variable named `my_cell`.\n- Set up an energy variable for the prey initialized with a random value up to `max_energy`, ensuring that it diminishes over time due to `energy_consum` and does not exceed `max_energy`.\n- Include an `init` block in which the prey’s initial location is set to the location of `my_cell`.\n- Implement a `reflex` named `basic_move` allowing the prey to move to a random neighboring cell within a distance of 2 steps (`my_cell.neighbors2`), updating its location accordingly.\n- Create a `reflex` labeled `eat` that is executed when there is food available in `my_cell`. Within this reflex, define the energy transfer from the cell to the prey based on available food and `max_transfer`.\n- Add a `reflex` called `die` that triggers when the prey's energy level falls to zero or below, resulting in the prey’s death (`do die`).\n- Design an `aspect` named `base` to visually represent the prey in the simulation environment. It should draw a circle using its `size` and `color` attributes.\n\n\nMake sure that the code allows for interactions between the `prey` and its environment, reflecting energy transfer dynamics and the ability to move and survive based on energy levels.",
        "answer": "species prey {\n   float size <- 1.0;\n   rgb color <- #blue;\n   float max_energy <- prey_max_energy;\n   float max_transfer <- prey_max_transfer;\n   float energy_consum <- prey_energy_consum;\n      \n   vegetation_cell my_cell <- one_of(vegetation_cell);\n   float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n  \n   init {\n       location <- my_cell.location;\n   }\n\n\n   reflex basic_move {\n       my_cell <- one_of(my_cell.neighbors2);\n       location <- my_cell.location;\n   }\n\n\n   reflex eat when: my_cell.food > 0 {\n       float energy_transfer <- min([max_transfer, my_cell.food]);\n       my_cell.food <- my_cell.food - energy_transfer;\n       energy <- energy + energy_transfer;\n   }\n\n\n   reflex die when: energy <= 0 {\n       do die;\n   }\n\n\n   aspect base {\n       draw circle(size) color: color;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Develop a GAML code snippet that configures a grid representing vegetation cells. Detail the grid's properties and the internal attributes of the cells as follows:\n\n\n- Define the grid with the name `vegetation_cell` and set its size to a width of 50 and a height of 50 cells. Specify that each cell should consider 4 neighbors.\n- Inside the `vegetation_cell` species, declare a constant `float` variable `max_food` with a value of `1.0`.\n- Generate an initial `float` variable `food_prod` to represent food production, assigning it a random value up to `0.01`.\n- Establish a `float` variable `food`, representing the amount of food available in the vegetation cell, with a random initial value up to `1.0`. Ensure that this value cannot exceed `max_food` and is set to increment by `food_prod` at every update.\n- Create an `rgb` type variable `color` that reflects the food availability in the cell. The red and blue components of the RGB color should inversely correlate with the `food` variable (i.e., lower food leads to higher red and blue values), while the green component remains constant at `255`. Update this color to reflect changes in the food variable dynamically.\n- Define a list of `vegetation_cell` type named `neighbors2`. This list should be populated with neighboring cells at a distance of 2 grid steps from the current cell.\n\n\nThis snippet should allow the modeling of a dynamic grid in which food production and availability alter the appearance of each cell, and neighboring relationships are established for further interactions in the simulation.\n",
        "answer": "grid vegetation_cell width: 50 height: 50 neighbors: 4 {\n   float max_food <- 1.0;\n   float food_prod <- rnd(0.01);\n   float food <- rnd(1.0) max: max_food update: food + food_prod;\n   rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n   list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Generate GAML code to create a grid with cells of width and height set to 100 units. Inside each cell, generate a random float value 'grid_value' using the 'rnd' function based on the distance from the cell to the world location. Calculate an RGB color 'color' using the random value, where the red component is determined by scaling 'grid_value' within the range [0, 100].",
        "answer": "grid cell width: 100 height: 100 {\n\tfloat grid_value <- rnd(1.0,self distance_to world.location);\n\trgb color <- rgb(255 * (1 - grid_value / 100), 0,0);\n}",
        "nickname": "z"
      },
      {
        "question": "Create a complete model that shows the evacuation of human agents indoors towards an exit. The agents will be moving in discretised 3D space, avoid the barriers (walls), and should not overlap with one another.",
        "answer": "model evacuationgoto\n\nglobal {\n\t//Shapefile of the walls\n\tfile wall_shapefile <- shape_file(\"../includes/walls.shp\");\n\t//Shapefile of the exit\n\tfile exit_shapefile <- shape_file(\"../includes/exit.shp\");\n\t//DImension of the grid agent\n\tint nb_cols <- 50;\n\tint nb_rows <- 50;\n\t\n\t//Shape of the world initialized as the bounding box around the walls\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tinit {\n\t\t//Creation of the wall and initialization of the cell is_wall attribute\n\t\tcreate wall from: wall_shapefile {\n\t\t\task cell overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the exit and initialization of the cell is_exit attribute\n\t\tcreate exit from: exit_shapefile {\n\t\t\task (cell overlapping self) where not each.is_wall{\n\t\t\t\tis_exit <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the people agent\n\t\tcreate people number: 50{\n\t\t\t//People agent are placed randomly among cells which aren't wall\n\t\t\tlocation <- one_of(cell where not each.is_wall).location;\n\t\t\t//Target of the people agent is one of the possible exits\n\t\t\ttarget <- one_of(cell where each.is_exit).location;\n\t\t}\n\t}\n}\n//Grid species to discretize space\ngrid cell width: nb_cols height: nb_rows neighbors: 8 {\n\tbool is_wall <- false;\n\tbool is_exit <- false;\n\trgb color <- #white;\t\n}\n//Species exit which represent the exit\nspecies exit {\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n//Species which represent the wall\nspecies wall {\n\taspect default {\n\t\tdraw shape color: #black depth: 10;\n\t}\n}\n//Species which represent the people moving from their location to an exit using the skill moving\nspecies people skills: [moving]{\n\t//Evacuation point\n\tpoint target;\n\trgb color <- rnd_color(255);\n\t\n\t//Reflex to move the agent \n\treflex move {\n\t\t//Make the agent move only on cell without walls\n\t\tdo goto target: target speed: 1.0 on: (cell where not each.is_wall) recompute_path: false;\n\t\t//If the agent is close enough to the exit, it dies\n\t\tif (self distance_to target) < 2.0 {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw pyramid(2.5) color: color;\n\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\n\t}\n}\nexperiment evacuationgoto type: gui {\n\tfloat minimum_cycle_duration <- 0.04; \n\toutput {\n\t\tdisplay map type: 3d axes:false{\n\t\t\timage \"../images/floor.jpg\";\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies exit refresh: false;\n\t\t\tspecies people;\n\t\t\t\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Draft a GAML code snippet to generate a visually appealing histogram-type bar chart with the following specifications:\n\n\n- Begin by setting up a `display` with the identifier `nice_bar_chart` configured to render in 2D.\n- Inside this display, establish a chart titled \"Nice Cumulative Bar Chart\". This chart should be defined with a histogram type.\n- Set the background color to dark blue (`#darkblue`) and the color for bars to light green (`#lightgreen`).\n- Define the chart axes color to also be light green (`#lightgreen`).\n- Customize the font settings for various elements of the chart:\n - Set the title font to 'Serif', with a size of 32.0 and style `italic`.\n - Configure the tick font to 'Monospaced', size 14, with a `bold` emphasis.\n - Assign the label font to 'Arial', size 18, and also `bold`.\n - For the legend, choose 'SanSerif', size 14, and style it `bold`.\n- Control the vertical range of the chart (`y_range`) to be between -20 and 40.\n- Determine the vertical axis tick unit (`y_tick_unit`) to be 10.\n- Label the horizontal axis as 'Nice Xlabel' and the vertical axis as 'Nice Ylabel'.\n- Include within the chart definition, the following three datasets with individual characteristics:\n - Dataset \"BCC\" should graph values using `10*cos(100*cycle)` and present a cumulative pattern (accumulate_values set to true). Employ a stacking style (`style:stack`) and color the bars yellow (`#yellow`).\n - Dataset \"ABC\" should plot values via `10*sin(100*cycle)` also in a stacked, cumulative fashion. Match the color of bars to blue (`#blue`).\n - Dataset \"BCD\" should represent values based on `(cycle mod 10)` and follow the same accumulation and stacking settings. Additionally, designate `marker_circle` as the marker shape used for this data.\n\n\nEnsure the snippet generates an interactive and cumulative bar chart where the data dynamically accumulates over simulation cycles and the aesthetic choices deliver a \"nice\" thematic look.\n",
        "answer": "display \"nice_bar_chart\"  type: 2d {\n   chart \"Nice Cumulative Bar Chart\" type:histogram\n       background: #darkblue\n       color: #lightgreen\n       axes: #lightgreen\n       title_font: font('Serif', 32.0, #italic)\n       tick_font: font('Monospaced', 14, #bold)\n       label_font: font('Arial', 18, #bold)\n       legend_font: font('SanSerif', 14, #bold)\n       y_range:[-20,40]\n       y_tick_unit:10\n       x_label:'Nice Xlabel'\n       y_label:'Nice Ylabel'\n       {\n       data \"BCC\" value:10*cos(100*cycle)\n           accumulate_values: true                    \n           style:stack\n           color:#yellow;\n       data \"ABC\" value:10*sin(100*cycle)\n           accumulate_values: true                    \n           style: stack\n           color:#blue;\n       data \"BCD\" value:(cycle mod 10)\n           accumulate_values: true                    \n           style: stack \n           marker_shape:marker_circle ;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model that represents how the K Nearest Neighbors Algorithm work. Whenever the user click on any location, a point will be generated and its color will be based on the colors of its k-nearest points. The user can also let the point generated dynamically and the colors of these points will also based on the colors of their k-nearest points.",
        "answer": "model KNearestNeighbors\n\n\nglobal {\n\n\tmap<unknown, unknown> store;\n\tlist<rgb> colour <- [#red, #blue, #green, #yellow, #purple, #orange, #pink, #magenta, #cyan];\n    int init_amount <- 10;\n    int nb_group <- 2;\n    float radius <- 10.0;\n    int k <- 10;\n\tinit {\n\t\tloop i from: 0 to: nb_group - 1{\n\t\t\tspecial_point center;\n\t\t\tcreate special_point{\n\t\t\t\tcolor <- colour[i];\n\t\t\t\tcenter <- self;\n\t\t\t}\n\t\t\tgeometry around <- circle(radius, center.location) intersection world.shape;\n\t\t\tcreate special_point number: init_amount - 1{\n\t\t\t\tlocation <- any_location_in(around);\n\t\t\t\tcolor <- center.color;\n\t\t\t}\n\t\t}\n\t\tstore <- world.special_point as_map (each::each.color);\n\t}\n\n\taction createAgent{\n\t    create special_point{\n\t    \tlocation <- #user_location;\n\t    \tcolor <- self k_nearest_neighbors (store, k);\n\t\t    store <+ (self::color);\n\t    }\n\t}\n\n\treflex auto{\n\t\tcreate special_point{\n\t   \t\tcolor <- self k_nearest_neighbors (store, k);\n\t   \t\tstore <+ self::color;\n\t   \t}\n\t}\n}\n\nspecies special_point {\n\tfloat size <- 0.5;\n\trgb color;\n\taspect base{\n\t\tdraw circle(size) color:color;\n\t}\n\t\n}\n\nexperiment demo {\n\tparameter \"Number of groups: \" var:nb_group min: 2 max: 9;\n\tparameter \"Radius: \" var: radius min:10.0 max:30.0;\n\tparameter \"Initial numbers of agent for each group: \" var:init_amount min:1 max:50;\n\tparameter \"Number of neighbours considered (K)\" var:k min:1;\n\toutput {\n\t\tdisplay main {\n\t\t\tspecies special_point aspect: base;\n\t\t\tevent #mouse_down {ask simulation {do createAgent;}} \n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Generate a model containing a 900 square spatial units (named plot and organized as a grid) containing a wild cabbage biomass. \nThe carrying capacity of each plot is a random value between 10 and 0 biomass.  \nInitially, the cabbages biomass is random between 0 and the local carrying capacity.\nWild cabbage biomass grows with a logistic function with a growth rate equal to 0,2.\nDisplay the maps of biomass and of carrying capacity.",
        "answer": "model cabbages\n\nglobal {\n\n\tfloat growth_rate <- 0.2 ;\n\tfloat max_carrying_capacity <- 10.0;\n\n}\n\ngrid plot height: 30 width: 30 neighbors: 8 {\n\n\tfloat biomass;\n\tfloat carrying_capacity;\n\trgb color <- rgb(0,255*biomass/max_carrying_capacity,0)\n\t\tupdate: rgb(0,255*biomass/max_carrying_capacity,0);\t\t\n\t\n\tinit {\t\t\n\t\tcarrying_capacity <- rnd(max_carrying_capacity);\t\t\n\t\tbiomass <- rnd(carrying_capacity);\n\t\tcolor <-  rgb(0,255*biomass/max_carrying_capacity,0);\t\n\t}\t\n\t\n\treflex grow {\n\t\tif(carrying_capacity != 0){\n\t\t\tbiomass <- biomass * (1 + growth_rate * (1 - biomass/carrying_capacity));\t\n\t\t}\n\t}\n}\n\n\nexperiment cabbagesExp type: gui {\n\toutput {\n\t\tdisplay biomass {\n\t\t\tgrid plot border: #black;\n\t\t}\n\t}\n}",
        "nickname": "patrick"
      },
      {
        "question": "Create a species called equipped with the ability to move in a 3D environment. The cell has a built-in reflex named \"move\" that triggers the actual movement action at each step.",
        "answer": "species movingAgent skills: [moving3D] {\n\treflex move {\n\t\tdo move;\n\t}\n}",
        "nickname": "Guest"
      },
      {
        "question": "Create a GAML model that simulates a world with buildings. Each building has to be created from a shape file 'buildings.shp'. Each building have an in-built attributes called 'height' that represents the height of the building",
        "answer": "init\n{\n  file buildings_shapefile <- file(\"building.shp\");\n  create building from: buildings_shapefile;\n}\n\nspecies building {\n\tfloat height <- rnd(10#m, 20#m) ;\n}",
        "nickname": "Guest"
      },
      {
        "question": "Import common shelling segregation gaml into current model.",
        "answer": "import \"../includes/Common Schelling Segregation.gaml\"",
        "nickname": "julius"
      },
      {
        "question": "Create a list named list list_of_size_10_with_0 with 10 elements with initial values of 0.",
        "answer": "list list_of_size_10_with_0 <- list_with(10, 0);",
        "nickname": "julius"
      },
      {
        "question": "Create a GAML code snippet for a model named \"NewModel\" that incorporates the following components and directives:\n\n\n- Declare a global species to define global variables and initialization processes.\n - Within the global scope, initialize an integer variable `number_of_agents` and set its value to `5`.\n - In the global `init` component, write the directive to create `number_of_agents` instances of a species named `my_node`.\n - Define a new species called `my_node` which inherits from a `graph_node` and is linked by an edge species named `edge_agent`.\n - Equipped the `my_node` species with a method called `related_to` that takes another `my_node` as a parameter and always returns `true`, indicating a relationship.\n - Provide the visual representation (aspect) for `my_node` species:\n - Include an `aspect` named `base` that instructs how to draw the node as a green circle with a radius of `1`.\n\n\n- Declare a second species named `edge_agent` as a child of `base_edge`.\n - For `edge_agent`, define an `aspect` also called `base` which sets the visualization guidelines to draw the agent with a blue shape.\n - Set up an experiment called `MyExperiment` of type `gui`.\n - Within the experiment, configure an output section that includes a display named `MyDisplay` using `java2D`.\n   - Ensure the display shows species `my_node` using their defined `base` aspect.\n   - Also, instruct the display to represent species `edge_agent` using its `base` aspect.\n\n\nMake sure the code encompasses the setup of networked agents interacting in a defined space and visibly represented in a two-dimensional Java-based simulation environment.\n",
        "answer": "model NewModel\n\n\nglobal {\n   int number_of_agents <- 5;\n\n\n   init {\n   create my_node number: number_of_agents;\n   }\n}\n\n\nspecies my_node parent: graph_node edge_species: edge_agent {\n   bool related_to (my_node other) {\n   return true;\n   }\n\n\n   aspect base {\n   draw circle(1) color: #green;\n   }\n}\n\n\nspecies edge_agent parent: base_edge {\n   aspect base {\n   draw shape color: #blue;\n   }\n}\n\n\nexperiment MyExperiment type: gui {\n   output {\n   display MyDisplay type: java2D {\n       species my_node aspect: base;\n       species edge_agent aspect: base;\n   }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete Schelling segregation model using gis data.",
        "answer": "model segregation\n\n//Import the model Common Schelling Segregation\nimport \"../includes/Common Schelling Segregation.gaml\" \nglobal {\n\t//List of all the free places\n\tlist<space> free_places  ;  \n\t//List of all the places\n\tlist<space> all_places ;\n\t//Neighbours distance for the perception of an agent\n\tint neighbours_distance <- 50 min: 1 parameter: \"Distance of perception:\" category: \"Population\" max: 1000;\n\t//Shapefile to load\n\tfile shape_file_name <- file(\"../gis/nha2.shp\") parameter: \"Shapefile to load:\" category: \"GIS specific\";\n\t//Shape of the environment\n\tgeometry shape <- envelope(shape_file_name);\n\t//Square meters per people in m2\n\tint square_meters_per_people <- 200 parameter: \"Occupancy of people (in m2):\" category: \"GIS specific\";\n\t\n\t//Action to initialize people agents\n\taction initialize_people { \n\t\t//Create all the places with a surface given within the shapefile\n\t\tcreate space from: shape_file_name with: [surface :: float(read(\"AREA\"))];\n\t\tall_places  <- shuffle(space);\n\t\t//Compute the number of people to create considering the density of people\n\t\tnumber_of_people <- int( density_of_people * sum (all_places collect (each.capacity))); \n\t\tcreate people number: number_of_people;  \n\t    all_people <- people as list ; \n\t    //Move all the people to a new place\n\t\task people  {  \n\t\t\tdo move_to_new_place;       \n\t\t}   \n\t}      \n\t//Action to initialize the places\n\taction initialize_places {}   \n\t\n} \n\n//Species people representing the people\nspecies people parent: base { \n\t//Size of the people agent\n\tfloat size const: true <- 2.0;\n\t//Color of the people agent  \n\trgb color const: true <- colors at (rnd (number_of_groups - 1)); \n\tint red const: true <- (color as list) at 0; \n\tint green const: true <- (color as list) at 1;  \n\tint blue const: true <- (color as list) at 2;  \n\t//Building in which the agent lives\n\tspace current_building <- nil;\n\t//List of all the neighbour people agents\n\tlist<people> my_neighbours -> people at_distance neighbours_distance; \n\t\n\t//Action to move to a new place\n\taction move_to_new_place {  \n\t\tcurrent_building <- (shuffle(all_places) first_with (((each).capacity) > 0));\n\t\task current_building {\n\t\t\tdo accept one_people: myself;   \n\t\t}\n\t}\n\t//Reflex to migrate to another place if the agent isn't happy\n\treflex migrate when: !is_happy {\n\t\tif current_building != nil {\n\t\t\task current_building { \n\t\t\t\tdo remove_one one_people: myself;\n\t\t\t}\n\t\t} \n\t\tdo move_to_new_place;\n\t}\n\n\taspect simple {\n\t\tdraw circle(5) color: color border: #black;\n\t}\n}\n\n//Species space representing a space for a people agent to live in\nspecies space {\t\n\t//List of all the people agents living within\n\tlist<people> insiders;\n\trgb color <- rgb(255, 255, 255); \n\t//Surface of the place\n\tfloat surface;\n\t//Capacity of the place\n\tint capacity  <- 1 + int(surface / square_meters_per_people);\n\t\n\t//Action to accept a people agent  \n\taction accept (people one_people) {\n\t\tadd one_people to: insiders;\n\t\tlocation of one_people <- any_location_in(shape);\n\t\tcapacity <- capacity - 1;\n\t}\n\t//Action to remove a people agent\n\taction remove_one (people one_people){\n\t\tremove one_people from: insiders;\n\t\tcapacity <- capacity + 1;\n\t}\n\taspect simple {\n\t\tcolor <- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw  square(40) color: color;\n\t}\n\taspect gis {\n\t\tcolor <- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw shape color: color border: #black;\n\t} \n\taspect highlighted {\n\t\tcolor <- #blue;\n\t\tdraw shape+10 color: color;\n\t}\n}\n\n\nexperiment schelling type: gui {\t\n\toutput {\n\t\tdisplay Town_display type:2d  {\n\t\t\tspecies space aspect: gis;\n\t\t\tspecies people  aspect: simple;\n\t\t}\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow ;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  ((sum_happy_people * 100) / number_of_people)  style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model showing how to represent a flooding system with dykes and buildings. The model should use a grid to discretize space, and will have a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.",
        "answer": "model hydro\n\nglobal {\n\t\n   //Shapefile for the river\n   file river_shapefile <- file(\"../includes/RedRiver.shp\");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file(\"../includes/Dykes.shp\");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file(\"../includes/Building.shp\");\n   \n   //Data elevation file\n   file dem_file <- file(\"../includes/mnt50.asc\");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n   \t //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n      \talready <- false;\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle  {\n   \t  //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n      \t//If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t//The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t//Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t//We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n   \t //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n   //layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart \"Pressure on Dykes\" type: series legend_font: font(\"Helvetica\", 18)  label_font: font(\"Helvetica\", 20, #bold)  title_font: font(\"Helvetica\", 24, #bold){\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}",
        "nickname": "julius"
      },
      {
        "question": "Create a complete simple SI model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected.",
        "answer": "model si\n\nglobal { \n\t\n    int number_S <- 495;  // The number of susceptible\n    int number_I <- 5 ;\t// The number of infected\n    float survivalProbability <- 1/(70*365) ; // The survival probability\n\tfloat beta <- 0.05 ; \t// The parameter Beta\n\tfloat nu <- 0.001 ;\t// The parameter Nu\n\tint numberHosts <- number_S+number_I; //Total number of hosts\n\tbool local_infection <- true ; //Infection spread locally or not\n\tint neighbours_size <- 2 ; //Size of the neighbourhood\n\tgeometry shape <- square(50);\n\tinit { \n\t\t//Creation of all the susceptible hosts\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  rgb(46,204,113);\n        }\n        //Creation of all the infected hosts\n        create Host number: number_I {\n            is_susceptible <-  false; \n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  rgb(231,76,60);  \n       }\n   }\n   //Reflex to update the number of infected hosts\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }  \n}\n\n//Grid to discretize space\ngrid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #white;\n\tlist<si_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n//Species host which represent the possible hosts of a disease\nspecies Host  {\n\t//Booleans to represent the state of the agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- rgb(46,204,113);\n    int sic_count <- 0;\n    si_grid myPlace;\n    \n    //The agent is placed randomly among the grid\n    init {\n    \tmyPlace <- one_of (si_grid as list);\n    \tlocation <- myPlace.location;\n    }        \n    //Reflex to move the agents in its neighbourhood\n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    //Reflex to infect the agent if it is susceptible and according to the other infected agents\n    reflex become_infected when: is_susceptible {\n    \tfloat rate <- 0.0;\n    \tif(local_infection) {\n    \t\tint nb_hosts <- 0;\n    \t\tint nb_hosts_infected <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {\n    \t\t\t\tnb_hosts_infected <- nb_hosts_infected + 1;\n    \t\t\t}\n    \t\t}\n    \t\trate <- nb_hosts_infected / nb_hosts;\n    \t} else {\n    \t\trate <- number_I / numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  rgb(231,76,60);    \n        }\n    }\n    //Reflex to kill the agent according to the death rate\n    reflex shallDie when: flip(nu) {\n\t\tcreate species(self) {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t// The number of infected\n    parameter \"Survival Probability\" var: survivalProbability ; // The survival probability\n\tparameter \"Beta (S->I)\" var:beta; \t// The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n\t\n \toutput {\n \t\tlayout #split; \n\t    display si_display  type:2d antialias:false{\n\t        grid si_grid border: #lightgray;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10#cycles)  type: 2d  {\n\t\t\tchart \"Susceptible\" type: series background: #white style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: rgb(46,204,113);\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: rgb(231,76,60);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Create a generic species with moving skill.",
        "answer": "species generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Given a field called \"heatmap\", create an experiment named \"Show heatmap\" with a gui type. Set up the output layout to split. Add a display named 'Other' of type 3D. Ensure that this display has a black background and is viewed from an upward-facing front camera angle. Visualize the heatmap data using a mesh. Use the 'Reds' color scheme from the Brewer colors palette. Ensure that the visualization accounts for the increasing values by enabling triangulation.",
        "answer": "experiment \"Show heatmap\" type: gui {\n\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t// Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "Give a GAML code snippet that outlines a complex node system with specific behaviors, attributes, and visual markers as follows:\n\n\n- Begin by defining a species named `my_node`, which extends from `graph_node` and associates with an edge species `edge_agent`.\n- Introduce an integer attribute `status` within `my_node` with an initial value of `0`.\n- Declare a list of integers `list_connected_index` to store the indexes of connected nodes.\n\n\n- Inside the species, implement an `init` block where:\n - A loop iterates through each node of type `my_node`.\n - Within this loop, use the probabilistic `flip(0.1)` function to decide whether to link the current node with another by adding an index to `list_connected_index`.\n - Define a boolean method `related_to` that takes another `my_node` as a parameter and returns `true` if `list_connected_index` contains the index of `other` node.\n\n\n- Create an action `update_neighbors` that:\n - Gathers a list of neighboring nodes by invoking `my_graph neighbors_of (self)`.\n - Iterates over this list, setting each neighbor’s `status` attribute to `1`.\n\n\n- Configure an `aspect` named `base` to visually represent the nodes based on their `status`:\n - If `status` equals `0`, draw a green circle with a black border.\n - If `status` equals `1`, draw a yellow circle with a black border.\n - If `status` equals `2`, draw a red circle with a black border.\n - Additionally, superimpose the degree of the node (from `my_graph`) as a black string on the visualization, adjusting the position relative to the node's location.\n - Reset the `status` to `0` at the end of the aspect, preparing it for the next cycle.\n\n\nEnsure the code effectively creates dynamic and interactive nodes that visually indicate their status and connectivity within a network structure, with the ability to be further manipulated or queried within the GAMA simulation environment.\n",
        "answer": "species my_node parent: graph_node edge_species: edge_agent {\n   int status <- 0;\n   list<int> list_connected_index;\n  \n   init {\n   int i <- 0;\n   loop g over: my_node {\n       if (flip(0.1)) {\n       add i to:list_connected_index;\n       }\n       i <- i+1;\n   }\n   }\n  \n   bool related_to(my_node other){\n       if (list_connected_index contains (my_node index_of other)) {\n       return true;\n   }\n       return false;\n   }\n  \n   action update_neighbors {\n   list<my_node> list_neighbors <- my_graph neighbors_of (self);\n\n\n   loop neighb over: list_neighbors {\n       neighb.status <- 1;\n   }\n   }\n\n\n   aspect base {\n   if (status = 0) {\n       draw circle(2) color: #green border: #black;\n   } else if (status = 1) {\n       draw circle(2) color: #yellow border: #black;\n   } else if (status = 2) {\n       draw circle(2) color: #red border: #black;\n   }\n  \n       draw string(my_graph degree_of self) color: #black size: 4 at: {self.location.x-1, self.location.y-2};\n   status <- 0;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "How to project a point in WGS 84 projection ? ",
        "answer": "point poi_location_WGS84 <- CRS_transform(poi_location, \"EPSG:4326\").location;",
        "nickname": "Arno"
      },
      {
        "question": "Create a complete model that shows the movement of boids following a goal, and creating a flock. In the experiment, the boids are dislayed in 3D and allows users to move the goal.",
        "answer": "model boids \nglobal torus: torus_environment{ \n\t//Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 500;\n\t//Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t//Variables for the movement of the boids\n\tfloat minimal_distance <- 30.0; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool torus_environment <- false; \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist<image_file> images  <- [image_file('../images/bird1.png'),image_file('../images/bird2.png'),image_file('../images/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t//Action to move the goal to the mouse location\n\taction move_goal {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: #user_location speed: 30.0;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t//Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t//Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n//Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t//If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45.0 speed: 20.0;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange wireframe: true;\n\t}\n} \n//Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t//Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t//action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t} else {\n\t\t\tif (location.x) < 0.0 {\n\t\t\t\tlocation <- {width_and_height_of_environment + location.x,location.y};\n\t\t\t} else if (location.x) > width_and_height_of_environment {\n\t\t\t\tlocation <- {location.x - width_and_height_of_environment ,location.y};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < 0.0 {\n\t\t\t\tlocation <- {location.x, width_and_height_of_environment + location.y};\n\t\t\t} else if (location.y) > width_and_height_of_environment {\n\t\t\t\tlocation <- {location.x,location.y - width_and_height_of_environment};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t//Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t//Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t\tdo bounding;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue wireframe: true;\n\t}\n} \n\n//Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\n\tinit {\n\t\tshape <- triangle(15);\n\t}\t\n\t//Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t//Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360.0;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment \"Basic\" type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky type: 3d axes:false{ \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t}\n\n\t}\n}\n\n\nexperiment \"Interactive\" type: gui autorun: true{\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\tbool previous_state <- gama.pref_synchronize_quadtree;\n\t\n\tinit {\n\t\t// The preference is explicitly set so as to avoid concurrency problems \n\t\tgama.pref_synchronize_quadtree <- true;\n\t}\n\t\n\tabort {\n\t\tgama.pref_synchronize_quadtree <- previous_state;\n\t}\n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky  background: #blue type: 3d fullscreen: 0 toolbar: false axes:false{ \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent #mouse_move {ask simulation {do move_goal;}}\n\t\t}\n\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Create an action move_goal that asks to move the goal to the mouse location.",
        "answer": "//Action to move the goal to the mouse location\n\taction move_goal {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: #user_location speed: 30.0;\n\t\t}\n\t}",
        "nickname": "julius"
      },
      {
        "question": "Generate a model that create agents by importing data of a CSV file. The model read the CSV File (iris.csv) and create an agent Iris for each line of the CSV, linking its attributes to columns of the CSV File (sepal_length, sepal_width,petal_length, petal_width,type). In addition the Iris species has a color attribute (value #blue if the type is Iris-setosa, #red is the type is Iris-virginica and #yellow otherwise). The color is used to display the Iris agents as a circle of radius petal_width.",
        "answer": "model CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t//create Iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t//we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate Iris from:csv_file( \"../includes/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies Iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies Iris;\n\t\t}\n\t}\n\t\n}\n",
        "nickname": "patrick"
      },
      {
        "question": "Create a square geometry named shape that matches a specified width and height of the environment.",
        "answer": "int width_and_height_of_environment <- 1000;\ngeometry shape <- square(width_and_height_of_environment);",
        "nickname": "julius"
      },
      {
        "question": "Write a GAML code snippet to establish a model entitled `multi_simulations` designed for initiating multiple simulation instances as below:\n\n\n- Start by defining a model named `multi_simulations`.\n- Set up a global scope that initializes each simulation instance:\n - Use the `init` block to send a notification each time a new simulation is created. This should output a message indicating the creation of a simulation and include its name (utilize the `name` variable).\n\n\n- Create an experiment named `my_experiment` of the `gui` type.\n - Incorporate an `init` block within the experiment, which will be intentionally left empty for potential future enhancements or initialization code.\n\n\n- Embed a reflex that is triggered on a specific condition during the simulation—each time the simulation cycle number is a multiple of 10 (excluding 0):\n - Employ the condition `(mod(cycle, 10) = 0 and cycle != 0)` to precisely fire the reflex every 10 cycles starting from cycle 10.\n - Within this reflex, issue a command to create a new instance of the simulation (represented by the `create simulation;` GAML statement).\n\n\n- Include an `output` block within the experiment to define how results or graphical interfaces should be displayed to the user. For now, it remains empty, serving as a placeholder for future coding elements or directives that may be needed for output management.\n\n\nThe snippet should facilitate running concurrent simulation instances at specified intervals, providing a basis for understanding or observing the behavior of multiple simulations in action.\n",
        "answer": "model multi_simulations\n\n\nglobal {\n   init {\n       write \"new simulation created ! Its name is \"+name;\n   }\n}\n\n\nexperiment my_experiment type:gui  {\n   init {\n   }\n   reflex when:(mod(cycle,10)=0 and cycle!=0) {\n       create simulation;\n   }\n   output {\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete and simple prey and predator comodel which serves to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.",
        "answer": "model prey_predator\n\n\nglobal\n{\n\tgeometry shape <- square(100);\n\tfloat perceipt_radius <- 20.0;\n\tint preyinit <- 500;\n\tint predatorinit <- 3;\n\tlist<agent> lstPredator;// <- list<agent> (predator);\n\tlist<agent> lstPrey; //<- list<agent> (prey);\n\tinit\n\t{\n\t\tcreate prey number: preyinit;\n\t\tcreate predator number: predatorinit;\n\t\tlstPredator <- list<agent> (predator);\n\t\tlstPrey <- list<agent> (prey);\n\t}\n\n}\n\nspecies generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}\n\nspecies prey parent: generic_species\n{\n\tgeometry shape <- circle(0.5);\n\tfloat speed <- 0.2;\n\trgb color <- # green;\n\treflex fleeing\n\t{\n\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)\n\t\t{\n\t\t\tspeed <- 1.0;\n\t\t\tis_chased <- true;\n\t\t\tcolor <- # lime;\n\t\t\tif (goal = nil)\n\t\t\t{\n\t\t\t\tagent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\n\t\t\t\tif (a != nil and !dead(a))\n\t\t\t\t{\n\t\t\t\t\tif (flip(0.5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- a.location;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t\t}\n\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (goal != nil and self.location distance_to goal < 0.5)\n\t\t{\n\t\t\tgoal <- nil;\n\t\t}\n\n\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)\n\t\t{\n\t\t\tis_chased <- false;\n\t\t\tcolor <- # green;\n\t\t\tspeed <- 0.2;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies predator parent: generic_species\n{\n\tgeometry shape <- triangle(2);\n\trgb color <- # red;\n\treflex hunting\n\t{\n\t\tif (goal = nil)\n\t\t{\n\t\t\tlist tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));\n\t\t\tif (length(tmp) > 0)\n\t\t\t{\n\t\t\t\tagent a <- first(tmp sort (each.shape distance_to self.shape));\n\t\t\t\tif (a = nil)\n\t\t\t\t{\n\t\t\t\t\ta <- any((lstPrey where (!dead(each))));\n\t\t\t\t}\n\n\t\t\t\tif (a != nil)\n\t\t\t\t{\n\t\t\t\t\tspeed <- 2.0;\n\t\t\t\t\tgoal <- a.location;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ((self.location distance_to goal < 0.5))\n\t\t{\n\t\t\task lstPrey where (!dead(each) and each.location distance_to goal < 0.5)\n\t\t\t{\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tgoal <- nil;\n\t\t\tspeed <- 1.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw circle(perceipt_radius) color: # pink wireframe: true;\n\t\tdraw shape color: color rotate: 90 + my heading;\n\t}\n\n}\n\nexperiment \"Prey Predator Exp\" type: gui\n{\n\toutput\n\t{\n\t\tdisplay main_display\n\t\t{\n\t\t\tspecies prey;\n\t\t\tspecies predator;\n\t\t}\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Create a model that displays the step to step algorithm of k-means over moving agents. In this model there 2 global parameters, 'n' being the number of datapoints agents and 'k' the number of cluster to create. \n\nThe clusters are represented as agents, cluster agent have an attribute giving the list of moving agent inside the cluster. The aspect of a cluster agent is a convex hull of the polygon created from the list of their datapoints. The color of this agent is randomly choosen.\n\nThe datapoints are represented as agents, they have a direct reference on the closest cluster agent as attribute. the datapoints agents are moving around each step using wander. the aspect of a datapoint is a circle taking the color of the cluster agent he is the closest to.\n\n\n",
        "answer": "model MASKMEANS\n\n\nglobal\n{\n\t// the number of classes to create (kmeans)\n\tint k <- 2;\n\t\n\t// the number of points\n\tint N <- 500;\n\t\n\tinit\n\t{\n\t\tcreate centroids number: k\n\t\t{\n\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t}\n\t\tcreate datapoints number: N\n\t\t{\n\t\t\tlocation <- { rnd(100), rnd(100)};\n\t\t\tmycenter <- centroids closest_to self;\n\t\t}\n\t\t\n\t\tloop tmp over: centroids\n\t\t{\n\t\t\ttmp.color_kmeans  <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t}\n\t}\n}\n\nspecies datapoints skills:[moving] \n{\n\trgb color_kmeans <- rgb(0,0,0) \t;\n\tcentroids mycenter;\n\t\n\treflex move \n    {\n    \tdo wander amplitude: 90.0;\n    }\n    \n    reflex when: mycenter != nil\n    {\t\t\n\t\tmycenter.mypoints <- mycenter.mypoints - self;\n\t\tmycenter <- centroids closest_to self;\n\t\t\n\t\tcolor_kmeans <- mycenter.color_kmeans;\n\t\tadd self to: mycenter.mypoints;\n    }\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw circle(0.5) color: color_kmeans border: color_kmeans - 25;\n\t}\n}\n\nspecies centroids\n{\n\trgb color_kmeans <-  rgb(225,225,225);\n\tlist<datapoints> mypoints;\n\t\n\treflex update_location when: length(mypoints) > 0\n\t{\n\t\tlocation <- mean(mypoints collect each.location); // move centroid in the middle of the convex\n\t\twrite(\"lenght : \" + length(mypoints));\n\t}\n\t\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw cross(3, 0.5) color: color_kmeans border: color_kmeans - 25;\n\t\t\n\t\tlist<geometry> li <- mypoints collect each.shape;\n\t\tgeometry convex <- convex_hull(polygon(li));\n\t\t\n\t\tdraw convex color: rgb(color_kmeans, 0.5);\n\t}\n}\n\nexperiment clustering2D type: gui\n{\n\toutput\n\t{\n\t\tdisplay map_kmeans \n\t\t{\n\t\t\tspecies datapoints aspect: kmeans_aspect2D transparency:0.4;\n\t\t\tspecies centroids aspect: kmeans_aspect2D;\n\t\t}\n\n\t}\n}",
        "nickname": "Guest"
      },
      {
        "question": "Generate a people species that can use the primitive of the moving skill. It represents an individual that can be infected or not. At each step, it will move randomly in the space. In addition, when it is infected, it will have a probability of proba_infection to infect all the people agents located at distance infection_distance. infection_distance and proba_infection are 2 existing global variables.\nIt may be displayed by drawing a circle of radius 5 and a color being red whether it is infected and green otherwise.",
        "answer": "species people skills: [moving] {\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif (flip(proba_infection)) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n}\n",
        "nickname": "patrick"
      },
      {
        "question": "Write a GAML code snippet for a model named `multi_simulations` featuring the initial creation of species and synchronized simulations with shared parameters:\n\n\n- Outline the structure of the model `multi_simulations`.\n- In the global species, use the `init` block for the instantiation of an entity from a species known as `my_species`.\n\n\n- Define the species `my_species` with a given movement capability:\n - Equip `my_species` with the skill `moving`.\n - Construct a `reflex update` that prompts the agent to engage in a random wandering behavior using the `do wander;` command.\n - Establish an `aspect base` for graphical representation. Within this aspect, direct to draw each agent as a green circle with a radius of `2`.\n\n\n- Develop an experiment titled `my_experiment` of the `gui` type:\n - Declare and initialize a floating-point variable `seedValue` with a default setting of `10.0`.\n - Assign the variable `seed` to `seedValue` to explicitly set the simulation’s random seed to this value.\n - Within the experiment's `init` block:\n   - Create a directive to spawn a new simulation instance. This instance should be initialized with the same seed as the original, ensuring identical random behaviors across simulations.\n\n\n- Introduce an `output` segment that configures the visual display aspect:\n - Define a display labeled `my_display`.\n - Inside the display, specify that entities of `my_species` are to be exhibited using the `base` aspect.\n\n\nThis GAML code snippet should deliver the foundational elements for conducting dual concurrent simulations with a shared randomness determinant—a particular seed value—enabling parallel experiments with replicable, randomized events.\n",
        "answer": "model multi_simulations\n\n\nglobal {\n   init {\n       create my_species;\n   }\n}\n\n\nspecies my_species skills:[moving] {\n   reflex update {\n       do wander;\n   }\n   aspect base {\n       draw circle(2) color:#green;\n   }\n}\n\n\nexperiment my_experiment type:gui  {\n   float seedValue <- 10.0;\n   float seed <- seedValue; // force the value of the seed.\n   init {\n       // create a second simulation with the same seed as the main simulation\n       create simulation with:[seed::seedValue];\n   }\n   output {\n       display my_display {\n           species my_species aspect:base;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model that shows pedestrians passing through a corridor.",
        "answer": "model corridor\n\nglobal {\n//Capture pedestrians parameter to define if wall will capture pedestrians\n\tbool capture_pedestrians <- false;\n\tint environment_width init: 8000;\n\tint environment_height init: 3000;\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\n\t//Pedestrians parameters\n\trgb pedestrian_color <- #green;\n\tfloat pedestrian_speed <- 10.0;\n\n\t//Wall parameters\n\tfloat corridor_width <- environment_width / 1.5;\n\tint corridor_wall_height <- 800;\n\tgeometry corridor_wall_0_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width / 2, corridor_wall_height / 2};\n\tgeometry corridor_wall_1_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width / 2, environment_height - (corridor_wall_height / 2)};\n\t\n\n\t//Corridor parameters\n\tfloat corridor_left_bounds <- (location.x - (corridor_width / 2));\n\tfloat corridor_right_bounds <- (location.x + (corridor_width / 2));\n\n\tinit {\n\t\tcreate corridor;\n\t}\n\n\treflex change_color when: every(200 #cycle) {\n\t\tpedestrian_color <- rnd_color(255);\n\t}\n\n\treflex generate_pedestrians when: every(4 #cycle) {\n\t\tcreate pedestrian number: 30 with: [color::pedestrian_color] {\n\t\t\tdo init_location({0, rnd(environment_height)});\n\t\t}\n\t}\n}\n\n//Species pedestrian which will move from one side of the experiment to another and destroy itself once the other side is reached\nspecies pedestrian skills: [moving] topology: (topology(shape - (corridor_wall_0_shape + corridor_wall_1_shape))) {\n\tpoint target_location;\n\trgb color;\n\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\ttarget_location <- {environment_width, loc.y};\n\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\t\n\t\n\treflex change_speed when: every(rnd(200) #cycle) {\n\t\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\n\t//Reflex to make the agent move to its target_location\n\treflex move {\n\t\tpoint previous_location <- location;\n\n\t\tif (location.y < corridor_wall_height) and (location.x <= (environment_width / 2)) {\n\t\t\tdo move heading: self towards {(environment_width / 2) - (corridor_width / 2), corridor_wall_height};\n\t\t} else if (location.y > environment_height - corridor_wall_height) and (location.x <= (environment_width / 2)) {\n\t\t\tdo move heading: self towards {(environment_width / 2) - (corridor_width / 2), environment_height - corridor_wall_height};\n\t\t} else {\n\t\t\tdo move heading: self towards target_location;\n\t\t}\n\t\tif (location.x = previous_location.x) { // No move detected\n\t\t\tdo move heading: self towards {environment_width, world.shape.location.y};\n\t\t}\n\t}\n\n\treflex arrived when: location.x >= target_location.x {\n\t\tdo die;\n\t}\n\n}\n\n//Species which represents the corridor\nspecies corridor {\n\tgeometry shape <- ((rectangle({corridor_width, environment_height})) at_location world.location) - (corridor_wall_0_shape + corridor_wall_1_shape);\n\n\t//Subspecies for the multi-level architectures : captured pedestrians in this case\n\tspecies captured_pedestrian parent: pedestrian schedules: [] {\n\t\tfloat release_time;\n\t}\n\n\t//Reflex to capture pedestrians if the parameter is checked\n\treflex aggregate when: capture_pedestrians {\n\t//If we have pedestrians inside the corridor, we capture them\n\t//We update the time during which a pedestrian is captured according to the time the pedestrian\n\t// should need to pass through the corridor if it wasn't captured\n\t\tcapture (pedestrian where (p: p.location.x between (corridor_left_bounds, corridor_right_bounds))) as: captured_pedestrian {\n\t\t\trelease_time <- time + ((corridor_width - (location.x - ((environment_width / 2) - (corridor_width / 2)))) / (pedestrian_speed - 2.5));\n\t\t} }\n\n\t\t//Reflex to release pedestrians which have already passed enough time in the corridor\n\t// which means if they weren't captured by the corridor, they would have finish passing through it\n\treflex disaggregate {\n\t\tlist tobe_released_pedestrians <- captured_pedestrian where (time >= each.release_time);\n\t\tif !(empty(tobe_released_pedestrians)) {\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world {\n\t\t\t\tlocation <- {((environment_width / 2) + (corridor_width / 2)), (location).y};\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nexperiment \"Corridor\" type: gui autorun: true {\n\tpoint button_location;\n\tbool button_hover;\n\tgeometry corridor_wall_0_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width / 2, corridor_wall_height / 2};\n\tgeometry corridor_wall_1_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width / 2, environment_height - (corridor_wall_height / 2)};\n\t\n\tinit {\n\t\tbutton_location <- {simulation.corridor_left_bounds + 100, 100};  \n\t}\n\toutput {\n\t\tdisplay defaut_display type: 2d background: #black fullscreen: true toolbar: false {\n\t\t\tgraphics back {\n\t\t\t\tdraw shape color: #black wireframe: false;\n\t\t\t\tdraw corridor_wall_0_display color: #gray wireframe: true;\n\t\t\t\tdraw corridor_wall_1_display color: #gray wireframe: true ;\n\t\t\t}\n\n\t\t\tspecies corridor {\n\t\t\t\tdraw shape color: #black;\n\t\t\t}\n\t\t\t\n\t\t\tagents \"Captured\" value: list(corridor(0).captured_pedestrian) transparency: 0.5 {\n\t\t\t\tdraw square(30) wireframe: false color: #white;\n\t\t\t}\n\n\t\t\tspecies pedestrian {\n\t\t\t\tdraw square(20) wireframe: false color: color;\n\t\t\t}\n\n\t\t\tgraphics front {\n\t\t\t\tdraw (capture_pedestrians ? \"Capturing\":\"Not capturing\") anchor: #left_center at: {corridor_left_bounds + 200, 100} color: !capture_pedestrians ? #darkred : #darkgreen font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Captured: \" + length(corridor(0).captured_pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 250} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Pedestrians: \" + length(pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 400} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Step duration (ms): \" + (duration copy_between (0, 4))) anchor: #left_center at: {corridor_left_bounds + 200, 550} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t}\n\n\t\t\tgraphics button {\n\t\t\t\tdraw circle(50) color: #darkgray at: button_location;\n\t\t\t\tdraw circle(40) color: !capture_pedestrians ? (button_hover ? #yellow : #red) : (button_hover ? #lightgreen : #darkgreen) at:  button_location;\n\t\t\t}\n\n\t\t\tevent #mouse_down {\n\t\t\t\tif (button_location distance_to #user_location <= 50) {\n\t\t\t\t\tcapture_pedestrians <- !capture_pedestrians;\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #mouse_move {\n\t\t\t\tbutton_hover <- (button_location distance_to #user_location <= 50);\n\t\t\t}\n\t\t}\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Generate a model with a species people, characterized by an attribute (is_infected, being true or false).\nThe global block should contain as global attribute the initial number of people (named nb_people, 500 by defaut) and the initial number of infected people (named nb_infected_init, 5 by default). nb_people people agents are created initially. Among the people agents, nb_infected_init are initialized as infected. The step duration is initialized to 1 minute, and the environment to a square with an edge of 500 meters.",
        "answer": "global {\n    int nb_people <- 500;\n    int nb_infected_init <- 5;\n    float step <- 1 #minutes;\n    geometry shape <- envelope(square(500 #m));\n\n\tinit {\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\n\t}\n\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n}",
        "nickname": "patrick"
      },
      {
        "question": "Propose a GAML code snippet to institute an experiment designated as 'Run 5 simulations' which has the capacity to serially initiate multiple simulation runs with the following specifications:\n\n\n- Label the experiment 'Run 5 simulations' and configure it as a batch type to allow for automated sequential runs.\n- Set the number of repetitions for the experiment to `5` to indicate the total number of simulations to be run in this batch sequence.\n- Include the `keep_seed` property set to `true`, ensuring that each simulation run in the batch uses the same seed for its random number generator, contributing to reproducible outcomes across runs.\n- Establish an `until` condition that dictates the termination of each simulation run, predicated on the simulation `time` surpassing `1000` units.\n\n\n- Integrate a `reflex` labeled as `end_of_runs`, intended to execute an action at the end of each simulation within the batch:\n - Begin with a counter variable `cpt` initialized to `0`. This will serve as an incremental index to uniquely name saved files.\n - Use the `ask simulations` statement to iterate through all current simulations.\n - Within the block, deploy a save command for the `people` species, exporting them to a shapefile—the format indicated by \"shp\".\n - Construct the file name by concatenating \"result/people_shape\", the current value of `cpt`, and the extension \".shp\".\n - Specify the attributes `is_infected` and `is_immune` to be saved in the shapefile under the field names \"INFECTED\" and \"IMMUNE\", respectively.\n - Increment `cpt` after each simulation run to ensure unique file naming for subsequent exports.\n\n\nThe resulting snippet should facilitate the execution of controlled batch simulation runs, retaining consistent randomness and collecting structured geographic data in the form of shapefiles for each run, enabling detailed post-process analysis.\n",
        "answer": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n   reflex end_of_runs {\n   int cpt <- 0;\n       ask simulations {\n           save people type: \"shp\" to: \"result/people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\", is_immune::\"IMMUNE\"];\n           cpt <- cpt + 1;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "How to get a random value from a exponential distribution with a specified value of the rate (lambda) parameter equal to 5 ?\n",
        "answer": "float var0 <- exp_rnd(5) ;",
        "nickname": "patrick"
      },
      {
        "question": "How to get an index of the given list with a probability following the (normalized) distribution described in the list ?\n",
        "answer": "int index <- rnd_choice([0.2,0.5,0.3]);",
        "nickname": "patrick"
      },
      {
        "question": "Write a GAML code snippet to implement an experiment named 'Run 5 simulations' that systematically conducts a series of simulation runs and captures specific statistical data at each step:\n\n- Designate the experiment with the title 'Run 5 simulations', setting it up as a batch operation to execute multiple consecutive trials.\n- Configure the experiment to repeat exactly `5` times, ensuring that a set number of simulation runs are completed.\n- Apply the `keep_seed` directive with a value of `true` to maintain the same initial conditions for each repeated run, providing consistent startup scenarios for comparative analysis.\n- Set a stopping condition using the `until` keyword, with the criteria being that the simulation cycle count (`cycle`) eclipses `1000`.\n\n- Establish a `reflex` within the experiment definition, denoted by `t`:\n  - Utilize the `save` instruction to regularly capture and output the simulation data to a file.\n  - Outline the data composition to be saved, which should include:\n    - The current simulation cycle number (`cycle`).\n    - The average number of infected individuals from all running simulations (acquired via `simulations mean_of each.nb_infected`).\n  - Instruct the code to output the gathered data into a file named \"result.txt\".\n  - Further specify that the saved file should follow the \"csv\" (comma-separated values) format for ease of data manipulation and review post-simulation.\n\nThis directive should enable the GAML model to autonomously run the prescribed number of simulations, ensuring data continuity via consistent seed usage, and systematically record key performance metrics to a CSV file for subsequent analytical purposes.",
        "answer": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( cycle > 1000 ) {\n   reflex t {\n       save [cycle, simulations mean_of each.nb_infected] to: \"result.txt\" type: \"csv\";\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "How to get the value 0 with a probability 0.2, 1 with a probability 0.5, and 2 with a probability 0.3 ? ",
        "answer": "int index <- rnd_choice([0.2,0.5,0.3]);",
        "nickname": "patrick"
      },
      {
        "question": "Create complete model that creates horizontal and vertical hexagonal grids.",
        "answer": "model HexagonalGrid\n\nglobal {\n\tstring orientation <- \"horizontal\" among: [\"horizontal\", \"vertical\"] parameter: true;\t\n\t\n\tinit {\n\t\task cell {color <- #white;}\n\t}\n\treflex show_neighborhood {\n\t\task cell {color <- #white;}\n\t\task one_of(cell) {\n\t\t\tcolor <- #red;\n\t\t\task neighbors {\n\t\t\t\tcolor <- #green;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";\n\n\nexperiment hexagonal type: gui{\n\toutput  synchronized:true{\n\t\tdisplay view type: 3d{\n\t\t\tgrid cell border: #black ;\n\t\t}\n\t}\n}",
        "nickname": "julius"
      },
      {
        "question": "Develop a GAML code snippet that orchestrates a simple model with hierarchical agent species and outputs an accumulated count of all instances. Follow these step-by-step instructions:\n\n- Initialize the `global` species with definitions for the simulation’s setting.\n  - Create an `init` block that generates two instances of a species named `child` and one instance of a species named `mother`.\n\n- Within the global scope, script a reflex called `update` that performs an action each simulation cycle:\n  - The action should retrieve and write the total count of all `mother` species instances, including both direct and indirect (subspecies) instances, to the console or log.\n\n- In the global context, compose a list-returning function called `get_all_instances` that:\n  - Receives a single parameter, `spec`, which is a species of the generic type `agent`.\n  - Calculates and returns a list of all agents of the specified species, plus all agents of any subspecies thereof. The accumulation of instances should be achieved using recursion with the `accumulate` keyword and by invoking `get_all_instances(each)` for each subspecies.\n\n- Declare a basic species identified as `mother`, which will act as a parent species in the hierarchy.\n  \n- Define a species called `child` as a subspecies of `mother`, allowing for its instances to be accounted for as part of the `mother` population in the global reflex.\n\nThis crafted code snippet should produce a simple agent-based model where agents can be parents and children, and each cycle updates the console with the current total count of a species, including its subspecies.",
        "answer": "global\n{\n   init {\n       create child number: 2;\n       create mother number: 1;\n   }\n   reflex update {\n       write length(get_all_instances(mother)); // will write 3 (1+2)\n   }\n   list<agent> get_all_instances(species<agent> spec) {\n       return spec.population +  spec.subspecies accumulate (get_all_instances(each));\n   }\n}\n\n\nspecies mother {}\n\n\nspecies child parent: mother {}",
        "nickname": "Tu"
      },
      {
        "question": "Here is my model:\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nCreate a batch experiment to determine what are the best values for the variables infection_rate and dying_proba to minimize the number of dead people in the simulation represented by the variable num_dead. Use the Particle Swarm Optimization (PSO) method to explore the parameter set. infection_rate cannot be smaller than 0.01 nor higher than 0.5 and dying_proba is defined between 0.01 and 0.2. The swarm will be composed of 3 particles, and will iterate 5 times. We consider a simulation over when 5000 seconds have passed in model time",
        "answer": "\n// This experiment explores two parameters with a PSO strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment PSO type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5  minimize: num_dead  ; \n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a grid cell with height 10, width 10, 6 neighbours and with horizontal orientation.",
        "answer": "// the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";",
        "nickname": "julius"
      },
      {
        "question": "Construct a GAML code snippet that defines a grid and an experiment with the following specifications:\n\n1. Declare a `grid` species named `MyGrid`.\n   - Within this grid, define two distinct visual aspects:\n     - Name the first aspect `firstAspect`. In this aspect, instruct GAML to visually represent each cell in the grid as a square with a side length of 1 unit.\n     - Create a second aspect, titled `secondAspect`, where each cell is visually represented as a circle with a radius of 1 unit.\n\n2. Establish an experiment named `MyExperiment` with a 'gui' interface type.\n   - Inside the experiment, configure an `output` section that will determine what the user sees during the simulation run:\n     - Lay the foundations for a display called `MyDisplay`, specifying that it should use the `opengl` rendering type for enhanced graphics capabilities.\n     - Indicate that the `MyGrid` species should be displayed in `MyDisplay` utilizing the visual representation defined in `firstAspect`.\n\nThis code will regulate the setup of a visual simulation platform, presenting a grid in which cells are depicted with the designed graphical aspects, and coupling the grid display with an interactive GUI experiment environment.\n",
        "answer": "grid MyGrid {\n   aspect firstAspect {\n       draw square(1);\n   }\n   aspect secondAspect {\n       draw circle(1);\n   }\n}\n\n\nexperiment MyExperiment type: gui {\n   output {\n       display MyDisplay type: opengl {\n           species MyGrid aspect: firstAspect;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "I have a model with two variables nb_preys and nb_predators that I want to save in a csv at the end of every simulation. A simulation ends either when the stop_sim action defined in the world returns true or if time is greater than end_cycle.\nMake me an experiment that will do that for 5 simulation runs.",
        "answer": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: world.stop_sim() or (time > end_cycle){\n\t\n\t// the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5)\n\treflex end_of_runs\n\t{\n\t\task simulations\n\t\t{\n\t\t\tsave [nb_preys,nb_predators] to: \"Results/preypredator.csv\" format:\"csv\" rewrite:false;\n\t\t}\n\t}\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Here is my model of disease infection:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nMake an experiment to determine which values of infection_rate and dying_proba minimize the number of dead after 5000s in simulation time. infection_rate should be comprised between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. To do so, use a genetic algorithm, with a population of 3, a probability of crossover of 0.7 a probability of mutation of 0.1 and stop after 5 generations.\n",
        "answer": "// This experiment explores two parameters with a GA strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 improve_sol: true stochastic_sel: false\n\tnb_prelim_gen: 1 max_gen: 5  minimize: num_dead  aggregation: \"min\";\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Here is my model of disease infection:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nMake an experiment to determine which values of infection_rate and dying_proba minimize the number of dead after 5000s in simulation time. infection_rate should be comprised between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. To do so, use an hill climbing algorithm, with a start value of 0.2 for infection_rate and 0.05 for dying_proba",
        "answer": "// This experiment explores two parameters with a Hill Climbing strategy from an explicit init solution (if no solution is given, start from a random sol),\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Hill_Climbing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.1;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod hill_climbing init_solution:map([\"infection_rate\"::0.2, \"dying_proba\":: 0.05])  minimize: num_dead aggregation: \"max\";\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a complete model to represent how to compute the shortest path from a grid (with the 4 algorithms: A*, Dijkstra, Jump Point Search (JPS) and Breadth First Search (BFS ).",
        "answer": "model Grid\n\nglobal {\n\t\n\t/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https://harablog.wordpress.com/2011/09/07/jump-point-search/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n\t*/\n\t\n\tstring scenario <- \"wall\" among: [\"random\", \"wall\"] parameter: true;\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tfloat obstacle_rate <- 0.1 min: 0.0 max: 0.9 parameter: true;\n\tint grid_size <- 50 min: 5 max: 100 parameter: true;\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\tinit toto {    \n\t\tif (scenario = \"wall\") {\n\t\t\task cell {is_obstacle <- false;}\n\t\t\tint x_max <- round(grid_size * 2/3);\n\t\t\tloop i from: 2 to:x_max {\n\t\t\t\tcell[i, 3].is_obstacle <- true;\n\t\t\t\tcell[i, grid_size - 4].is_obstacle <- true;\n\t\t\t}\n\t\t\tloop i from: 3 to: grid_size - 4 {\n\t\t\t\tcell[x_max, i].is_obstacle <- true;\n\t\t\t}\n\t\t\task cell {color <- is_obstacle ? #black : #white;}\n\t\t}\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell width: grid_size height: grid_size neighbors: neighborhood_type optimizer: algorithm{\n\tbool is_obstacle <- flip(0.1);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\n\t\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type: 2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tgraphics \"elements\" {\n\t\t\t\tdraw circle(1) color: #green at: source border: #black;\n\t\t\t\tdraw circle(1) color: #red at: goal  border: #black;\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: point(v);\n\t\t\t\t}\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Develop a GAML code snippet for a species called `duck`, which employs a strategy pattern for flying behaviors and provides a way to visualize these behaviors:\n\n\n1. Begin by declaring a new species `duck`.\n  - Include an attribute `f` of type `fly_behavior` which will hold the current flying strategy.\n\n\n2. Define an action `set_fly_behavior` within `duck`:\n  - This action should take a single parameter `new_f` of type `fly_behavior`.\n  - Inside this action, assign the `f` attribute to this new passed-in behavior, effectively changing the duck's flying strategy.\n\n\n3. Implement an action `perform_fly` for the `duck` species:\n  - Utilize the `ask` scope to command `f`, the flying behavior, to execute its embedded `fly` action.\n\n\n4. Additionally, declare within `duck` an `action` named `my_display`.\n  - Mark this action as `virtual: true`, signifying that it should be overridden by any subspecies or be explicitly defined when creating instances of `duck`.\n\n\nEnsure the code snippet reflects the ability of a `duck` instance to dynamically change and perform its flying behavior, illustrating an aspect of behavioral design patterns within the GAML structure.\n",
        "answer": "species duck {\n   fly_behavior f;\n\n\n   action set_fly_behavior (fly_behavior new_f) {\n       f <- new_f;\n   }\n  \n   action perform_fly {\n       ask f {\n           do fly;\n       }\n   }\n  \n   action my_display virtual: true;\n  \n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a reflex that calculates the path in a grid from a source cell to a goal cell using the cell topology, and avoiding obstacles.",
        "answer": "reflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}",
        "nickname": "julius"
      },
      {
        "question": "Design a GAML code snippet to define a foundational agent species called `duck`, as well as two distinct subclasses that inherit from it and exhibit different behaviors and display messages:\n\n1. Start with a species declaration for `duck`:\n   - Assign an attribute `f` of type `fly_behavior`, which will serve to hold a reference to a current flying strategy.\n   \n2. Within the `duck` species, create an action named `set_fly_behavior`:\n   - This action should accept a parameter `new_f` of the `fly_behavior` type.\n   - Set the `duck`'s `f` attribute to the new behavior received as an argument.\n\n3. Implement an action called `perform_fly`:\n   - Compose this action to operate within the context of the contained `f` attribute and trigger its `fly` action.\n\n4. Declare an action `my_display` within `duck` species:\n   - Make sure this action is virtual (i.e., intended to be overridden) by adding the `virtual: true` attribute.\n\n5. Add a reflex block that invokes both the `perform_fly` and `my_display` actions within the `duck` species.\n\n6. Create a subclass of `duck` named `model_duck`:\n   - Within the 'init' block, instantiate a `fly_no_way` behavior and assign it to the `f` attribute of `model_duck` to indicate its inability to fly.\n   \n7. Define an overridden `my_display` action in `model_duck` that outputs \"i am a model duck\".\n\n8. Construct another subclass named `real_duck` which also inherits from `duck`.\n   - In the 'init' block, create a `fly_with_wings` behavior reflecting the capability of real ducks to fly and assign this behavior to `real_duck`’s `f` attribute.\n   \n9. Similar to `model_duck`, include an overridden `my_display` action in `real_duck` that expresses \"i am a real duck\".\n\nThis GAML script should encapsulate the functionalities required for creating a generic `duck` species capable of changing its flying behavior dynamically and two specialized `duck` species, `model_duck` and `real_duck`, each with distinct flying capacities and self-identification messages.",
        "answer": "species duck {\n   fly_behavior f;\n  \n   action set_fly_behavior (fly_behavior new_f) {\n       f <- new_f;\n   }\n  \n   action perform_fly {\n       ask f {\n           do fly;\n       }\n   }\n  \n   action my_display virtual: true;\n  \n   reflex {\n       do perform_fly;\n       do my_display;\n   }\n}\n\n\nspecies model_duck parent: duck {\n   init {\n       create fly_no_way {\n           ask myself {\n               f <- myself;\n           }\n       }\n   }\n  \n   action my_display {\n       write \"i am a model duck\";\n   }\n}\n\n\nspecies real_duck parent: duck {\n   init {\n       create fly_with_wings {\n           ask myself {\n               f <- myself;\n           }\n       }\n   }\n  \n   action my_display {\n       write \"i am a real duck\";\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to find out what combination of values for the infection rate and the dying probabilities are the most efficient to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the tabu method with a list size of 5 and 5 iterations. ",
        "answer": "// This experiment explores two parameters with a Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod tabu iter_max: 5 tabu_list_size: 5 minimize: num_dead aggregation: \"max\";\n}\n",
        "nickname": "PasPatrick"
      },
      {
        "question": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to find out what combination of values for the infection rate and the dying probabilities are the most efficient to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the reactive tabu method with an initial list size of 5, 10 iterations and cycles with a size between 3 and 10. ",
        "answer": "\n// This experiment explores two parameters with a Reactive Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Reactive_Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod reactive_tabu iter_max: 10 cycle_size_max: 10 cycle_size_min: 3 tabu_list_size_init: 5 minimize: num_dead aggregation: \"max\";\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Write a GAML code snippet that fabricates a model comprising macro-species agents, each containing a random number of micro-species agents, with the objective to log the count of micro-species for each macro-species upon initialization:\n\n\n1. Define the `global` context:\n  - Start with an `init` block in the global scope that commands the creation of 5 `macro_species` agents.\n\n\n2. Declare a species named `macro_species`:\n  - Inside the `init` block for each `macro_species` instance:\n    - Instantiate a random number (from 1 to 10) of `micro_species_in_group` agents.\n    - Compose a `write` statement to log a message. This message should include the unique `name` of the `macro_species` agent and the `length` (count) of `micro_species_in_group` agents it contains.\n\n\n3. Within `macro_species`, outline the sub-species `micro_species_in_group` with no additional properties or actions. Its definition remains empty as it serves as an agent count inside its `macro_species`.\n\n\n4. Set up an experiment by the name of `my_experiment` with the interface type `gui`. This should be left as an empty shell for further development, with no specific configurations or output prescribed at this time.\n\n\nThe resulting snippet will produce an outcome whereby upon each simulation start, each macro-species agent reports its number of micro-species agents, reflecting an agent-contained hierarchy and the dynamic instantiation of agents in GAML.\n",
        "answer": "global {\n   init {\n   create macro_species number:5;\n   }\n}\n\n\nspecies macro_species  {   \n   init {\n   create micro_species_in_group number: rnd(10);\n   write \"the macro species agent named \"+name+\" contains \"+length(micro_species_in_group)+\" agents of micro-species.\";\n   }\n\n\n   species micro_species_in_group { }\n}\n\n\nexperiment my_experiment type: gui { }\n",
        "nickname": "Tu"
      },
      {
        "question": "Can you give me an example model whereby a DEM file is rendered/displayed in 3D?",
        "answer": "model ThreeDModel\n\nglobal {\n\tmatrix<float> elevation_matrix <-  matrix<float>(image_file( \"images/ITP_colored_100.tif\") as_matrix {300, 300});\n\tinit {\n\t\televation_matrix <- elevation_matrix * (30 / (min(elevation_matrix)-max(elevation_matrix)));\n\t\task elevation {\n\t\t\tgrid_value <- elevation_matrix at {grid_x, grid_y};\n\t\t}\n\t}\n}\n\n\ngrid elevation  width: 300 height: 300;\n\nexperiment \"3D\"  type:gui {\n\t\n\toutput {\n\t\t\n\t\tdisplay trees type: opengl\n\t\t{ \n\t\t\tgrid elevation elevation: elevation_matrix texture: image_file( \"images/ITP_Reprojected_Filled_100.tif\") triangulation: true refresh: false;\n\t\t\t\n\t\t}\n\t}\n}",
        "nickname": "z"
      },
      {
        "question": "show me how to collect one attribute value over a set of agent, in order to plot the minimum, maximum and average value in a chart",
        "answer": "global {\nlist attvalues -> myagent collect (each.myattribute);\n}\n\nspecies myagent {\nfloat myattribute;\n}\n\nexperiment xp {\noutput {\ndisplay main {\nchart \"min max mean\" type:series {\n\t\t\t\tdata \"min\" value:min(attvalues);\n\t\t\t\tdata \"max\" value:max(attvalues);\n\t\t\t\tdata \"mean\" value:mean(attvalues);\n\t\t\t}\n}\n}\n}",
        "nickname": "Kevin"
      },
      {
        "question": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to approximate the values for the infection rate and the dying probabilities that would be the best to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the simulated annealing method with an end temperature of 10.0, an initial temperature of 50 and a decrease step of 0.5",
        "answer": "// This experiment explores two parameters with a Simulated annealing strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Simulated_annealing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod annealing  minimize: num_dead temp_decrease: 0.5 temp_end: 10.0 temp_init: 50;\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  // The init number of people\n    int number_I <- 5 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tfloat dying_proba <- 0.01; //probability to die at each step if infected\n\tint immune_step <- 100 ; // number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nShow me all the different methods I can use to explore the different values of infection_rate and dying_proba to minimize num_dead by the end of the simulation once time becomes greater than 5000.\nFor each method create a new experiment and comment it to explain what happens.\nthe values of infection_rate and dying_proba should always be respectively between 0.1 and 0.5 and between 0.01 and 0.2.",
        "answer": "\n// This experiment explores two parameters with a PSO strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment PSO type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5  minimize: num_dead  ; \n}\n\n// This experiment explores two parameters with a GA strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 improve_sol: true stochastic_sel: false\n\tnb_prelim_gen: 1 max_gen: 5  minimize: num_dead  aggregation: \"min\";\n}\n\n\n// This experiment explores two parameters with a Hill Climbing strategy from an explicit init solution (if no solution is given, start from a random sol),\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Hill_Climbing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.1;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod hill_climbing init_solution:map([\"infection_rate\"::0.2, \"dying_proba\":: 0.05])  minimize: num_dead aggregation: \"max\";\n}\n\n\n// This experiment explores two parameters with a Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod tabu iter_max: 5 tabu_list_size: 5 minimize: num_dead aggregation: \"max\";\n}\n\n// This experiment explores two parameters with a Reactive Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Reactive_Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod reactive_tabu iter_max: 10 cycle_size_max: 10 cycle_size_min: 3 tabu_list_size_init: 5 minimize: num_dead aggregation: \"max\";\n}\n\n// This experiment explores two parameters with a Simulated annealing strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Simulated_annealing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod annealing  minimize: num_dead temp_decrease: 0.5 temp_end: 10.0 temp_init: 50;\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Write a GAML code snippet that fabricates a model comprising macro-species agents, each containing a random number of micro-species agents, with the objective to log the count of micro-species for each macro-species upon initialization:\n\n\n1. Define the `global` context:\n  - Start with an `init` block in the global scope that commands the creation of 5 `macro_species` agents.\n\n\n2. Declare a species named `macro_species`:\n  - Inside the `init` block for each `macro_species` instance:\n    - Instantiate a random number (from 1 to 10) of `micro_species_in_group` agents.\n    - Compose a `write` statement to log a message. This message should include the unique `name` of the `macro_species` agent and the `length` (count) of `micro_species_in_group` agents it contains.\n\n\n3. Within `macro_species`, outline the sub-species `micro_species_in_group` with no additional properties or actions. Its definition remains empty as it serves as an agent count inside its `macro_species`.\n\n\n4. Set up an experiment by the name of `my_experiment` with the interface type `gui`. This should be left as an empty shell for further development, with no specific configurations or output prescribed at this time.\n\n\nThe resulting snippet will produce an outcome whereby upon each simulation start, each macro-species agent reports its number of micro-species agents, reflecting an agent-contained hierarchy and the dynamic instantiation of agents in GAML.\n",
        "answer": "global {\n   init {\n   create macro_species number:5;\n   }\n}\n\n\nspecies macro_species  {   \n   init {\n   create micro_species_in_group number: rnd(10);\n   write \"the macro species agent named \"+name+\" contains \"+length(micro_species_in_group)+\" agents of micro-species.\";\n   }\n\n\n   species micro_species_in_group { }\n}\n\n\nexperiment my_experiment type: gui { }",
        "nickname": "Tu"
      },
      {
        "question": "Write a GAML code snippet illustrating the concept of agent interaction between two species, named `speciesA` and `speciesB`, each with initialization behaviors and reflexive actions revealing the nuances of self-referencing keywords:\n\n\n1. Establish an agent species identified as `speciesA`:\n  - In the `init` block, assign the string \"speciesA\" to the predefined attribute `name`, which serves as the agent's identifier.\n \n2. Within `speciesA`, craft a `reflex` titled `update` to perform actions based on certain conditions or at every simulation cycle:\n  - Engineer an `ask` directive within the reflex that sends a message to all `speciesB` agents.\n  - Instruct the code to execute two `write` statements inside the `ask` block:\n    - The first statement should simply output the value of `name` within the context of `speciesB`.\n    - The second statement should prepend the `self` reference to `name`, confirming the context-specific behavior of `self`.\n    - The third statement should use `myself.name` to clarify how the `myself` keyword refers back to the agent governed by the outermost scope, in this case, `speciesA`.\n\n\n3. Declare another agent species called `speciesB`:\n  - Similarly, during the initialization of `speciesB`, equate its `name` attribute to the string \"speciesB\".\n\n\nThe aim of this snippet is to demystify the distinctions of `self` and `myself` in a multi-agent system where species interact or reference each other, and to understand their respective outputs within differing scopes of action.",
        "answer": "species speciesA {\n   init {\n       name <- \"speciesA\";\n   }\n   reflex update {\n       ask speciesB {\n           write name; // output : \"speciesB\"\n           write self.name; // output : \"speciesB\" write myself.name; // output : \"speciesA\" }\n       }\n   }\n}\nspecies speciesB {\n   init {\n       name <- \"speciesB\";\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "I have a model file at the path \"../../Tutorials/Predator Prey/models/Model 13.gaml\" I would like to reuse it but I don't want the it to save the simulation results as it is currently doing with the reflex save_result.\n\nCreate a model that could fix that",
        "answer": "\nmodel Exploration\n\nimport \"../../Tutorials/Predator Prey/models/Model 13.gaml\"\n\n/*\n * Change a little bit the behavior of the world agent to remove the saving of results\n */\nglobal {\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){ } // Overload method so we do not have any saved output\n\n}",
        "nickname": "PasPatrick"
      },
      {
        "question": "Create a complete model to demonstrate the role of the restitution in the collision of objects in the box2D library, which simulates physical interactions in 2 dimensions.",
        "answer": "model Box2D\n\nglobal parent: physical_world {\n\t\n\tint size <- 250;\n\t\n\tfloat seed <- machine_time;\n\tstring library <- \"box2D\";\n\t// The definition of the step plays a crucial role in the dynamics. If the physics engine can kick in at a high frequency, then the simulation is more accurate (but also slower). \n\t// The outcome of a model can be completely changed by the step. \n\tfloat step <- 1.0 / 100;\n\tfloat wall_restitution <- 1.0 min: 0.0 max: 2.0;\n\tfloat ball_restitution <- 0.9 min: 0.0 max: 1.0;\n\tgeometry shape <- box(size, size, 0.001);\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.0;\n\tbool accurate_collision_detection <- true; // expensive but much better\n\tint max_substeps <- 1;\n\tpoint ball_contact <- nil;\n\tint ball_timer <- 0;\n\tpoint wall_contact <- nil;\n\tint wall_timer <- 0;\n\tbool disturb <- true;\n\tlist<ball> movers;\n\n\tinit {\n\t\tdo register([self]);\n\n\t\tgeometry box <- box(size+3, 3, 10);\n\t\tcreate wall from: [box at_location ({size/2, 0}), box rotated_by 90 at_location ({0, size/2}), box at_location ({size/2, size}), box rotated_by 90 at_location ({size, size/2})];\n\t\tlist<point> starting_places <- [{5,5}, {5,size-5},{size-5,5}, {size-5,size-5}];\n\t\tcreate ball from: starting_places collect (circle(4) at_location each) with: [mass::10, color::#cadetblue, speed::30] returns: balls;\n\t\tmovers <-balls;\n\t\tloop x from: 5 to: size-5 step: 10 {\n\t\t\tloop y from: 5 to: size-5 step: 10 {\n\t\t\t\tif (x = 5) or (x = size-5) {\n\t\t\t\t\tif (y = 5) or (y = size-5) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tfloat n <- rnd(1.0, 4.5);\n\t\t\t\tcreate ball with: [shape::circle(n) at_location {x,y},mass::n, color::brewer_colors(\"Set3\")[int(n)], speed::n*2] {\n\t\t\t\t\tinitial_location <- location;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\n\t}\n\t\n\treflex when: every(1000#cycle){\n\t\task movers{\n\t\t\tfloat s <- speed * 2;\n\t\t\tvelocity <- velocity + {(rnd(s) * rnd(-1.0,1.0)), (rnd(s) * rnd(-1.0,1.0))};\n\t\t}\n\t}\n\n}\n\nspecies wall skills: [static_body] {\n\tfloat restitution <- wall_restitution;\n\tfloat friction <- 0.1;\n}\n\nspecies ball skills: [dynamic_body, moving] {\n\tpoint initial_location;\n\tfloat contact_damping <- 0.1;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.0;\n\tfloat restitution <- ball_restitution;\n\tfloat friction <- 0.1;\n\trgb color ;//<- one_of(brewer_colors(\"Set3\"));\n\n\n\treflex go_back when: every(10#cycle) and (abs(velocity.x) between(0.0,1.0)) and (abs(velocity.y) between(0.0,1.0)) {\n\t\tdo goto target: initial_location;\n\t}\n\n}\n\nexperiment \"Disturbance\" type: gui {\n\t\n\n\n\timage_file bang <- image_file(\"../images/bang.png\");\n\timage_file bam <- image_file(\"../images/bam.png\");\n\ttext \"This experiment uses the Box2D library to display particles that are disturbed randomly and try to get back to their original location when this happens. Try stopping the disturbance or increasing or decreasing the restitution to see what happens. Agents are provided also with the moving skill, and it is a good example of mixing a physics-based with a behavior-based dynamics\";\n\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Restitution\" type: 3d antialias: true axes: false {\n\n\t\t\tspecies ball {\n\t\t\t\tdraw shape color: color;\n\t\t\t\tdraw line(location, location + velocity) color: #black end_arrow: 1 width: 1;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model showing water flowing in a river bed.",
        "answer": "model Terrain\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t// We scale the DEM up a little\n\tfloat z_scale <- 0.5;\n\tfloat step <-  1.0/30;\t\n\tbool flowing <- true;\n\tpoint gravity <- {-z_scale/4, z_scale, -9.81};\n\tint number_of_water_units <- 1 min: 0 max: 10;\n\tlist<point> origins_of_flow <- [{17,3}, {55,3}];\n\tfield terrain <- field(grid_file(\"../images/DEM/RedRiver.asc\"));\n\n\tgeometry shape <- box({terrain.columns, terrain.rows, max(terrain)*z_scale});\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.5;\n\n\n\tinit {\n\t\tdo register([self]);\n\t}\n\n\treflex flow {\n\t\t\tloop origin_of_flow over: origins_of_flow {\n\t\t\t\tint x <- int(min(terrain.columns - 1, max(0, origin_of_flow.x + rnd(10) - 5)));\n\t\t\t\tint y <- int(min(terrain.rows - 1, max(0, origin_of_flow.y + rnd(10) - 5)));\n\t\t\t\tpoint p <- origin_of_flow + {rnd(10) - 5, rnd(10 - 5), terrain[x, y] + 4};\n\t\t\t\tcreate water number: number_of_water_units with: [location::p];\n\t\t\t}\n\t}\n}\n\nspecies water skills: [dynamic_body] {\n\tgeometry shape <- sphere(1.0);\n\tfloat friction <- 0.0;\n\tfloat damping <- 0.0;\n\tfloat mass <- 0.5;\n\trgb color <- one_of(brewer_colors(\"Blues\"));\n\t\n\n\taspect default {\n\t\tif (location.y > 10){\n\t\tdraw shape color: color;}\n\t}\n\t\n\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n} \n\nexperiment \"Four different scales\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::0.3];\n\t\tcreate simulation with: [z_scale::1.0];\n\t\tcreate simulation with: [z_scale::2.0];\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\tparameter \"Location of the camera\" var: camera_loc among: [#from_up_front, #from_above, #from_up_left, #from_up_right];\n\tparameter \"Distance of the camera\" var: distance min: 1 max: 1000 slider: true;\n \tparameter \"Number of water agents per cycle\" var: number_of_water_units;\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false {\n\t\t\tcamera #default location: camera_loc distance: distance dynamic: true;\n\t\t\tgraphics world {\n\t\t\t\tdraw \"Scale: \" + z_scale color: #cadetblue font: font(\"Helvetica\", 18, #bold) at: {world.location.x, -10, 25} anchor: #center depth: 2 rotate: -90::{1,0,0};\n\t\t\t\tdraw aabb wireframe: true color: #lightblue;\n\t\t\t}\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale smooth: 2;\n\t\t\tspecies water;\n\t\t\tevent #mouse_down {\n\t\t\t\tpoint p <- #user_location;\n\t\t\t\torigins_of_flow << {p.x, p.y};\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t\n\t\n\t}\n\t\nexperiment \"Largest scale\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false camera: #from_up_front{\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale;\n\t\t\tspecies water;\n\t\t}\n\n\t}}\n\t",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model that shows falling objects to demonstrate how the physics engine works. Ball agents fall on a floor, giggle a bit, exchange colors, and fall from the floor to the void. The user can click on any of them to give it some impulse.\n",
        "answer": "model Falling\n\n\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\tfloat restitution <- 0.8; // the \"bounciness\" of the world\n\tfloat friction <- 0.2; // the deceleration it imposes on other objects\n\tint environment_size <- 500; \n\tint max_substeps <-0;\n\tfloat step <- 0.006; \n\tgeometry shape <- box(environment_size,environment_size,10);\n\t\n\tinit {\n\t\t//If the world is to be considered as a physical object in the world, it must register itself\n\t\tdo register([self]);\n\t\tcreate ball number: 100;\n\t}\n} \n\n\nspecies ball skills: [dynamic_body] {\n\tfloat radius <- float(rnd(25) + 1);\n\tgeometry shape <- flip(0.3) ? cube(radius) : (flip(0.5) ? sphere(radius) : cone3D(radius, radius));\n\tpoint location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\trgb color <- #grey;\n\tfloat restitution <- 0.7;\n\tfloat mass <- 1.0;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.3;\n\tfloat friction <- 0.2;\n\n\t// A callback method when a contact is made with another agent. Here, we simply take its color\n\taction contact_added_with (agent other) {\n\t\tif (other is ball) {\n\t\t\tshape <- shape * 1.01;\t\n\t\t\tcolor <- rnd_color(255);\t\t\n\t\t\tdo update_body;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color rotate: rotation;\n\t\t// We can also draw the bounding box of the agent in the physical world\n//\tdraw aabb color: #black wireframe: true;\n\t}\n\n}\n\nexperiment Display type: gui {\n\toutput {\t\n\t\tdisplay Falling  type: 3d background:rgb(128,128,128) axes:false{\n\t\t\tcamera 'default' location: {177.8131,883.5764,615.7961} target: {250.0,250.0,0.0};\n\t\t\tgraphics World refresh: false{\n\t\t\t\t draw shape color: #white;\n\t\t\t}\n\t\t\tevent #mouse_down {\n\t\t\t\tball target <- ball with_min_of(each distance_to #user_location);\n\t\t\t\task target {\n\t\t\t\t\tdo apply impulse: {rnd(10)-5,rnd(10)-5,50}; // vertical, with some random side moves\n\t\t\t\t}\n\t\t\t}\n\t\t    species ball;\t\t\t\n\t\t}\n\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Develop a GAML code snippet that defines a species with a reflexive behavior to internally record nearby agents. The objectives are:\n\n\n1. Begin by declaring an agent species named `my_species`.\n2. Within this new species, outline a reflex named `update` to be executed regularly as part of the simulation cycle:\n  - Inside the reflex, generate a local variable `neighbors` of type `list<agent>`.\n  - Assign `neighbors` with the result of the `agents at_distance(5)` function call. This operation should collect all agents residing within a radius of 5 meters from the calling agent.\n\n\nThe desired snippet serves to develop the capability for an agent to assess its immediate environment and maintain a list of proximate agents, which is a foundational concept in simulating agent-environment interactions within the GAML paradigm.\n",
        "answer": "species my_species {\n   reflex update {\n       // neighbors contains the list of all the agents located at a distance <= 5 from the caller agent.\n       list<agent> neighbors <- agents at_distance(5);\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create ball species for falling objects model.",
        "answer": "species ball skills: [dynamic_body] {\n\tfloat radius <- float(rnd(25) + 1);\n\tgeometry shape <- flip(0.3) ? cube(radius) : (flip(0.5) ? sphere(radius) : cone3D(radius, radius));\n\tpoint location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\trgb color <- #grey;\n\tfloat restitution <- 0.7;\n\tfloat mass <- 1.0;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.3;\n\tfloat friction <- 0.2;\n\n\t// A callback method when a contact is made with another agent. Here, we simply take its color\n\taction contact_added_with (agent other) {\n\t\tif (other is ball) {\n\t\t\tshape <- shape * 1.01;\t\n\t\t\tcolor <- rnd_color(255);\t\t\n\t\t\tdo update_body;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color rotate: rotation;\n\t\t// We can also draw the bounding box of the agent in the physical world\n//\tdraw aabb color: #black wireframe: true;\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Develop a GAML code snippet that defines a species with a reflexive behavior to internally record nearby agents. The objectives are:\n\n\n1. Begin by declaring an agent species named `my_species`.\n2. Within this new species, outline a reflex named `update` to be executed regularly as part of the simulation cycle:\n  - Inside the reflex, generate a local variable `neighbors` of type `list<agent>`.\n  - Assign `neighbors` with the result of the `agents at_distance(5)` function call. This operation should collect all agents residing within a radius of 5 metres from the calling agent.\n\n\nThe desired snippet serves to develop the capability for an agent to assess its immediate environment and maintain a list of proximate agents, which is a foundational concept in simulating agent-environment interactions within the GAML paradigm.\n",
        "answer": "species my_species {\n   reflex update {\n       // neighbors contains the list of all the agents located at a distance <= 5 from the caller agent.\n       list<agent> neighbors <- agents at_distance(5);\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model of a vulcano, which is situated at the highest point of a DEM, erupts and the lava, falling down on the ground, erodes every patch of terrain it touches. The slope of the terrain evolves as more and more lava is produced (the epicenter of the eruption even changing when higher patches appear).",
        "answer": "model Vulcano\n/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent\n */\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t//Step (in #sec) passed to the physics engine. The same step is used for the simulation and the physics engine. The accuracy and synchronization\n\t//between the two can be controlled by max_substeps. A too large step (e.g. 1#sec) would make the lava 'pass through' the ground (tunnel effect).\n\t//A too small (e.g. 0.01), while more accurate, would, given the velocity of the lava, slow everything down on useless computations.\n\tfloat step <-  0.05;\n\t//A boolean that controls whether or not the lava will erode the ground\n\tbool erosion;\n\tfloat uncertainty -> {rnd(10.0) - 5};\n\t// Support for display parameters\n\tbool show_legend;\n\tbool draw_inside;\n\t//Every step the world creates a lava agent near the top of the highest patch in the terrain. It is provided with an initial high vertical velocity.\n\treflex flow {\n\t\tpatches highest <- patches with_max_of each.grid_value;\n\t\task highest {\n\t\t\tcreate lava number: 1 {\n\t\t\t\tlocation <- {highest.location.x + uncertainty, highest.location.y + uncertainty, highest.grid_value + uncertainty};\n\t\t\t\tvelocity <- velocity + {0,0,rnd(60) - 20};\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The patches come as a grid created after a simple DEM file and each cell is provided with a 'static body' in the physical world. The whole grid represents\n * an approximate terrain (or heightmap). Since the patches are agents, they can individually respond to events or have their own behavior, making the whole \n * a powerful way to describe dynamic environments.\n */\ngrid patches file: grid_file(\"../images/DEM/Volcano DEM.asc\") skills: [static_body] {\n\tfloat friction <- 0.5;\n\tfloat restitution <- 0.2;\n\t\n\t//This action is a 'callback' action, one of the two (with 'contact_removed_with') called by the physics engine when a contact occurs between two agents. \n\t// When redefined, it allows agents to react to contacts. Here, every new contact with a lava agent makes a patch decrease its height (grid_value) \n\t// and that of its neigbors by a small amount, as well as stop the lava agent quite brutally (clearing all the forces applied to it) to imitate \"stickiness\"\n\taction contact_added_with (agent other) {\n\t\tif (erosion) {\n\t\t\tgrid_value <- max(0,grid_value - 0.01);\n\t\t\task neighbors {\n\t\t\t\tgrid_value <- max(0,grid_value - 0.005);\n\t\t\t\tdo update_body;\n\t\t\t}\n\t\t\tdo update_body;\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tif (draw_inside) {draw aabb wireframe: true border: #white;}\n\t}\n}\n\n/**\n * Species that represents the lava erupting from the vulcano. Their physical body will be a sphere, weighting 4#kg, offering no restitution but a lot of friction.\n */\nspecies lava skills: [dynamic_body] {\n\tgeometry shape <- sphere(0.75);\n\tfloat mass <- 1.0;\n\trgb color <- one_of (brewer_colors(\"Reds\"));\n\tfloat restitution <- 0.2;\n\tfloat friction <- 0.3;\n\tfloat damping <- 0.1;\n\tfloat angular_damping<-0.1;\n\n\t//When a lava agent falls from the edges of the world, it is removed from the simulation (and the physical world as well).\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: color; \n\t\tif (draw_inside) {\n\t\t\tdraw aabb color: #lightblue wireframe: true;\n\t\t\tdraw line(location, location+velocity) color: #yellow end_arrow: 1 width: 1;\n\t\t}\n\t}\n\n} \n\n\nexperiment \"3D view\" type: gui {\n\tfont title  <- font(\"Helvetica\", 12, #bold);\n\tparameter \"Show inside structures (velocities and aabbs)\" var: draw_inside <- false;\n\tparameter \"Better collision detection\" var: accurate_collision_detection <- false;\n\tparameter \"Enable erosion\" var: erosion <- false;\n\tparameter \"Show legend\" var: show_legend <- true;\n\toutput {\n\t\t\n\t\tdisplay \"3D\" type: 3d axes: false background: #black camera:#from_up_front antialias: false {\n\t\t\tgraphics title {\n\t\t\t\tif (show_legend) {\n\t\t\t\t\tdraw \"Average height \" + (patches mean_of each.grid_value) with_precision 2 + \" / # of lava agents \" + length(lava) color: #white font: title at: {world.location.x, 100, patches max_of each.grid_value + 10} anchor: #center depth: 2 rotate: -20::{1,0,0};\n\t\t\t\t}\n\t\t\t}\n\t\t\t//The terrain is represented as a field (but could be equally represented as a grid\t\t\n\t\t\tmesh patches  texture: image_file(\"../images/DEM/Volcano Texture.jpg\") triangulation: true ;\n\t\t\t//We add to the representation the individual 'aabb's (axis-aligned bounding boxes) of the patches if 'draw_inside' is true\n\t\t \t//species patches;\n\t\t \t//Finally, each lava agent is represented (with its velocity if 'draw_inside' is true)\n\t\t\tspecies lava;\n\t\t}\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Assuming I have a field called \"heatmap\", create a species named \"worm\" with the moving skill. Define two reflexes within this species: \"wander\" and \"mark\". The \"wander\" reflex should move the worm randomly with an amplitude of 5.0 and a speed of 0.01. The \"mark\" reflex should update the heatmap field by adding 0.1 to the value at the worm's current location.",
        "answer": "species worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "Write a GAML code snippet for a model entitled `connect_the_neighbors` that simulates autonomous agents within a space, exhibits their movement, and visually connects each agent with its neighbors under certain conditions:\n\n\n1. Start with the model definition, `model connect_the_neighbors`.\n2. In the `global` scope, declare three variables:\n  - `speed`, a floating-point variable, which dictates the randomness of agent movement, initialized to `0.2`.\n  - `distance_to_intercept`, another float, representing the maximum distance at which agents will visually connect to one another, set to `10.0`.\n  - `number_of_circle`, an integer that represents the total number of agents to create, initialized to `100`.\n3. In the same global scope, write an `init` block that creates `number_of_circle` instances of `my_species`.\n\n\n4. Define the species `my_species`:\n  - Incorporate a reflex called `move` that randomly alters the location of an agent within a speed-limited range.\n  - Visualize `my_species` with an `aspect default`: Draw each agent as a yellow circle with a black border.\n  - Within the aspect code, use the `ask` command to select neighboring agents within `distance_to_intercept`:\n    - For each neighboring agent, draw a polyline from the neighbor (`self.location`) to the current agent (`myself.location`), representing the connection with a black line.\n\n\n5. Draft an experiment named `my_experiment` with a graphical user interface (`gui`):\n  - Under this experiment, define an `output` block containing a `display` named `myDisplay`.\n  - Inside the display configuration, specify that instances of `my_species` should be shown using the `default` aspect.\n\n\nFollowing the completion of these steps, the model will illustrate how agents can move independently within a virtual space and dynamically identify and visually connect with proximate agents.\n",
        "answer": "model connect_the_neighbors\nglobal{\n   float speed <- 0.2;\n   float distance_to_intercept <- 10.0;\n   int number_of_circle <- 100;\n   init {\n       create my_species number:number_of_circle;\n   }\n}\nspecies my_species {\n   reflex move {\n       location <- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};\n   }\n   aspect default {\n   draw circle(1) color: #yellow border: #black;\n   ask my_species at_distance(distance_to_intercept) {\n       draw polyline([self.location,myself.location]) color:#black; }\n   }\n}\nexperiment my_experiment type:gui {\n   output{\n       display myDisplay {\n           species my_species aspect:default;\n       }\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model showing waterflow from a digital elevation model (DEM). Upstream and downstream cells are determined automatically.",
        "answer": "model WaterOnFields\n\n\nglobal {\n\tgrid_file dem_file <- file(\"../includes/DEM_100m_PP.asc\");\n\tfield terrain <- field(dem_file) ;\n\tfield flow <- field(terrain.columns,terrain.rows);\n\t//Shape of the environment using the dem file\n\tgeometry shape <- envelope(dem_file);\n\tbool fill <- false;\n\n\t//Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\tint frequence_input <- 3;\n\tlist<point> drain_cells <- [];\n\tlist<point> source_cells <- [];\n\tmap<point, float> heights <- [];\n\tlist<point> points <- flow points_in shape;\n\tmap<point, list<point>> neighbors <- points as_map (each::(flow neighbors_of each));\n\tmap<point, bool> done <- points as_map (each::false);\n\tmap<point, float> h <- points as_map (each::terrain[each]);\n\tfloat input_water;\n\tinit {\n\t\tgeometry river_g <- first( file(\"../includes/river.shp\"));\n\t\tfloat c_h <- shape.height/flow.rows;\n\t\tlist<point>  rivers_pt <- points where ((each overlaps river_g) and (terrain[each] < 100.0)) ;\n\t\tif (fill) {\n\t\t\tloop pt over: rivers_pt  {\n\t\t\t\tflow[pt] <- 1.0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y <  (c_h)) {\n\t\t\t\tsource_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y > (shape.height - (c_h) )) {\n\t\t\t\tdrain_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\t\n\t}\n\n\t//Reflex to add water among the water cells\n\treflex adding_input_water when: every(frequence_input#cycle){\n\t\tloop p over: source_cells {\n\t\t\tflow[p] <- flow[p] + input_water;\n\t\t}\n\t}\n\n\t//Reflex for the drain cells to drain water\n\treflex draining  {\n\t\tloop p over: drain_cells {\n\t\t\tflow[p] <- 0.0;\n\t\t}\n\t}\n\n\n\tfloat height (point c) {\n\t\treturn h[c] + flow[c];\n\t}\n\n\t//Reflex to flow the water according to the altitude and the obstacle\n\treflex flowing {\n\t\tdone[] <- false;\n\t\theights <- points as_map (each::height(each));\n\t\tlist<point> water <- points where (flow[each] > 0) sort_by (heights[each]);\n\t\tloop p over: points - water {\n\t\t\tdone[p] <- true;\n\t\t}\n\t\tloop p over: water {\n\t\t\tfloat height <- height(p);\n\t\t\tloop flow_cell over: (neighbors[p] where (done[each] and height > heights[each])) sort_by heights[each]  {\n\t\t\t\tfloat water_flowing <- max(0.0, min((height - heights[flow_cell]), flow[p] * diffusion_rate));\n\t\t\t\tflow[p] <- flow[p] - water_flowing;\n\t\t\t\tflow[flow_cell] <- flow[flow_cell] + water_flowing;\n\t\t\t\theights[p] <- height(p) ;\n\t\t\t\theights[flow_cell] <- height(flow_cell) ;\n\t\t\t}\n\t\t\tdone[p] <- true;\n\t\t}\n\t}\n}\n\n\nexperiment hydro type: gui {\n\tparameter \"Input water at source\" var: input_water <- 1.0 min: 0.0 max: 3.0 step: 0.1;\n\tparameter \"Fill the river\" var: fill <- true;\n\toutput {\n\t\tdisplay d type: 3d {\n\t\t\tcamera 'default' location: {7071.9529,10484.5136,5477.0823} target: {3450.0,3220.0,0.0};\n\t\t\tmesh terrain scale: 10 triangulation: true  color: palette([#burlywood, #saddlebrown, #darkgreen, #green]) refresh: false smooth: true;\n\t\t\tmesh flow scale: 10 triangulation: true color: palette(reverse(brewer_colors(\"Blues\"))) transparency: 0.5 no_data:0.0 ;\n\t\t}\n\n\t}\n\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Load a DEM file as a grid.",
        "answer": "grid_file dem_file <- file(\"../includes/DEM_100m_PP.asc\");",
        "nickname": "julius"
      },
      {
        "question": "You are tasked to write a GAML code snippet that establishes a hierarchy of species in which a child species inherits a movement skill from its parent and exhibits its own distinct movement behavior:\n\n\n1. Define a primary species named `mother_species`:\n  - Endow `mother_species` with the `moving` skill from the list of GAMA built-in skills to grant basic movement functionalities.\n\n\n2. Create a `child_species` that forms a subclass of `mother_species`:\n  - In the `init` block of `child_species`, initialize the `speed` attribute to `2.0`, specifying how fast the agents of this species will move.\n  - Add a `reflex` named `update`, stimulated at each simulation step, where the agents perform the `wander` action derived from the `moving` skill, allowing them to move randomly within the environment.\n\n\nEnsure the correct parent-child species relationship is portrayed, demonstrating the inheritance of skills and the customization of properties within the GAML framework.\n",
        "answer": "species mother_species skills:[moving] { }\nspecies child_species parent:mother_species {\n   init {\n       speed <- 2.0;\n   }\n   reflex update {\n       do wander;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model of water flow where space is discretised in a grid. The river is a set of cells, each of them with an elevation. The data comes from a data elevation model (DEM) file. The upstream cells (i.e. the source cells) and the downstrem cells (i.e. the drain cells) are chosen by the modeler. At each step, the cells transmits a part of their water to their neighbor cells that are lower (their height is computed taken into account their elevation and height of water.",
        "answer": "model Waterflowgridelevation\n\nglobal {\n\tfile dem_file <- file(\"../includes/DEM_100m_PP.asc\");\n\tfile river_file <- file(\"../includes/river.shp\");\n \n  \t //Shape of the environment using the dem file\n  \t geometry shape <- envelope(dem_file);\n\t\n\t//Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\t\n\tlist<cell> drain_cells;\n\tlist<cell> source_cells;\n\t\n\tfloat input_water;\n\t\n\tinit {\n\t\tcreate river from: river_file;\n\t\tdo init_cells;\n\t\tdo init_water;\n   \t  \t//Initialization of the drain cells\n\t\tdrain_cells <- cell where (each.is_drain);\n\t\tsource_cells <- cell where(each.is_source);\n\t\task cell {do update_color;}\n\t}\t\n\t\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\t\n   \n   action init_water {\n      ask cell overlapping first(river) {\n         //water_height <- 3.0;\n         is_source <- grid_y = 0;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }   \n\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- input_water;\n      ask source_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   \n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask cell {already <- false;}\n      ask (cell sort_by ((each.altitude + each.water_height))) {\n         do flow;\n      }\n   }\n   \n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell {\n         do update_color;\n      }\n   }\n   \n   //Reflex for the drain cells to drain water\n   reflex draining when: false{\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }   \n\t\n//\treflex d {\n//\t\twrite \"min  \" + cell min_of(each.grid_value);\n//\t\twrite \"max  \" + cell max_of(each.grid_value);\t\t\n//\t}\n}\n\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {\n\tfloat altitude;\n\tfloat water_height;\n\tfloat height;\n\tlist<cell> neighbour_cells;\n\tbool is_drain;\n\tbool is_source;\n\tbool already;\n\n     //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height ;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n}\n\nspecies river {\n\taspect default {\n\t\tdraw shape color: #red;\n\t}\n}\n\nexperiment hydro type: gui {\n\tparameter \"input water\" var: input_water <- 1.0;\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\t//species river;\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Create a GAML code snippet that simulates the relationship between a parent species 'mother' and a subspecies 'child', and defines a function to count all instances of a species, including its subspecies:\n\n\n1. Initiate a `global` scope:\n  - Within the `init` section, instruct the creation of 2 `child` agents and 1 `mother` agent.\n\n\n2. Within the `global` scope, define a `reflex` named `update`:\n  - This reflex should invoke a `write` action to display the total number of `mother` agents. Note that this count should include all instances of `mother`, as well as all instances of any subspecies therein.\n\n\n3. Provide a method `get_all_instances` in the same global context:\n  - This method should accept one parameter, `spec`, typed as a generic `species<agent>`.\n  - It should return a list of all agent instances of the given species `spec`, plus all agent instances from any of its subspecies. Utilize the `+` operator to concatenate the populations and apply `accumulate` in conjunction with `get_all_instances(each)` to recursively include all subspecies' instances.\n\n\n4. Declare an agent species labeled `mother`, which does not require additional configuration for this task.\n\n\n5. Define a subspecies named `child` that is a descendant of the `mother` species.\n\n\nAfter completing these steps, the code should allow the simulation to run and effectively count the total number of 'mother' and 'child' instances, considering the 'child' agents as part of the 'mother' group for tallying purposes.\n",
        "answer": "global\n{\n   init {\n           create child number: 2;\n           create mother number: 1;\n       }\n   reflex update {\n       write length(get_all_instances(mother)); // will write 3 (1+2)\n   }\n   list<agent> get_all_instances(species<agent> spec) {\n       return spec.population + spec.subspecies accumulate (get_all_instances(each));\n   }\n}\nspecies mother {}\nspecies child parent: mother {}\n",
        "nickname": "Tu"
      },
      {
        "question": "Develop a GAML code snippet that defines the dynamics of a population through the lens of individual lifespan and birth processes. Begin by declaring a species named 'people.' Each person should have an 'age' attribute that initializes based on a Gaussian distribution with a mean of 40 and a standard deviation of 15.\n\n\nEach simulation step, individuals should experience a 'reflex' named 'older,' signifying the passage of time, which increments their age by 1.\n\n\nAdditionally, conceptualize a 'reflex' named 'die,' which introduces the concept of mortality based on the individual's age, with the chance of dying increasing progressively with age. This reflex should be triggered by a probabilistic condition, simulating a natural death process with a small likelihood dependent on age.\n\n\nUpon the event of death, a new individual should be immediately created signifying birth, with 'age' initialized to 0 to represent an infant. Also, ensure the original individual is removed from the population post-creation of the new individual, simulating the cycle of life and death in the population.\n",
        "answer": "species people {\n   float age <- gauss(40.0, 15.0);\n   reflex older {\n       age <- age + 1;\n   }\n   reflex die when: flip(age / 1000) {\n       create people {\n           age <- 0.0;\n       }\n       do die;\n   }\n}\n",
        "nickname": "Tu"
      },
      {
        "question": "Create a complete model showing water flow in a river graph, using water flow in rivers. The graph is created from a shapefile. THe points of interest in the river also comes from a poi shapefile. The flow of water is modeled through the exchange of water between elements of rivers. Then the water flows toward the outlet point. ",
        "answer": "model Waterflowrivergraph\n\nglobal {\n\tfile river_shape_file <- shape_file(\"../includes/rivers.shp\");\n\tfile poi_file <- shape_file(\"../includes/poi.shp\");\n\n\tgeometry shape <- envelope(river_shape_file) + 500;\n\t\n\tgraph the_river;\n\tpoi outlet;\n\n\tinit {\n\t\tcreate river from: river_shape_file;\n\t\tcreate poi from: poi_file;\n\t\toutlet <- poi first_with(each.type = \"outlet\");\n\t\tthe_river <- as_edge_graph(river);\n\t\n\t\task poi - outlet{\n\t\t\tclosest_river <- river closest_to self;\n\t\t\tpath path_to_outlet <- path_between(the_river,self,outlet);\n\t\t\tloop i from: 0 to: length(path_to_outlet.edges) - 2 {\n\t\t\t\triver(path_to_outlet.edges[i]).next_river <- river(path_to_outlet.edges[i+1]);\n\t\t\t}\n\t\t} \n\t}\n\t\n\treflex water_flow {\n\t\t// Every 20 simulation steps, the source points provide water to the closest river.\n\t\tif (every(10#cycles)) {\n\t\t\task poi - outlet {\n\t\t\t\tdo give_water;\n\t\t\t}\t\n\t\t//  For a visualisation purpose, the water flow is not executed when the sources provide water.\n\t\t} else {\t\t\n\t\t\task river {\n\t\t\t\tdo water_flow;\n\t\t\t}\n\t\t\task river {\n\t\t\t\tdo update_water_level;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\nspecies poi {\n\tstring type;\n\triver closest_river ;\n\t\n\taction give_water {\n\t\tclosest_river.water_volume <- 200.0;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(500) color: (type=\"source\") ? #green : #red border: #black;\t\t\n\t}\t\n}\n\nspecies river {\n\triver next_river ;\n\tfloat water_volume;\n\tfloat water_volume_from_other;\n\t\n\taction water_flow {\n\t\tif (next_river != nil) {\n\t\t\tnext_river.water_volume_from_other <- next_river.water_volume_from_other + 0.9 * water_volume;\n\t\t}\n\t}\n\t\n\taction update_water_level {\n\t\twater_volume <- 0.1 * water_volume + water_volume_from_other;\n\t\twater_volume_from_other <- 0.0;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: #blue;\t\n\t\tdraw shape + water_volume color: #blue;\n\t\t\n\t\t\t\n\t}\n}\n\nexperiment flow type: gui {\n\toutput {\n\t \tdisplay \"Water Unit\" type:2d { \n\t\t\tspecies river ; \n\t\t\tspecies poi;\t\t\t\n\t\t}\n\t}\n}\n",
        "nickname": "julius"
      },
      {
        "question": "Calculate true or false given the probability represented by the operand, for example 0.66666.",
        "answer": "bool var0 <- flip (0.66666); // var0 equals 2/3 chances to return true.",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model that generates a digital elevation model (DEM), with several features (which can be interpreted at will: sea, shore, mountain...).",
        "answer": "model RandomMaps\n\nglobal {\n\t// the generation is mostly governed by these values (see the documentation of 'generate_terrain')\n\tfloat details <- 0.5;\n\tfloat smoothness <- 0.4;\n\tfloat scattering <- 0.7;\n\tint width <- 250;\n\tint height <- 250;\n\tfield terrain;\n\tstring palette_name <- \"Seaside\";\n\tint generator_seed <- 1;\n\n\tinit {\n\t\tdo generate();\n\t}\n\n\taction generate {\n\t\t// the generate_terrain operator returns a field where the elevations are between 0 and 1. It can be scaled afterwards.\n\t\tint scale_factor <- palette_name = \"Seaside\" ? 20 : 10;\n\t\tterrain <- generate_terrain(generator_seed, width, height, details, smoothness, scattering) * scale_factor;\n\t}\n\n}\n\nexperiment Terrain type: gui {\n\t\n\tparameter \"Seed for the generator\" var: generator_seed <- 1 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Width of the environment\" var: width min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\tparameter \"Height of the environment\" var: height min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Level of details\" var: details min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of smoothness\" var: smoothness min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of scattering\" var: scattering min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Palette\" var: palette_name  among: [\"Countryside\",\"Seaside\"] {\n\t\tdo update();\n\t}\n\t\n\tuser_command \"Save\" {\n\t\tdo save_tif();\n\t}\n\n\taction update {\n\t\task simulation {\n\t\t\tdo generate();\n\t\t}\n\t\tdo update_outputs();\n\t}\n\t\n\taction save_tif {\n\t\tstring file_name <- \"seed\"+generator_seed+\"w\"+width+\"h\"+height+\"d\"+(details with_precision 2)+\"smooth\"+(smoothness with_precision 2)+\"scatter\"+(scattering with_precision 2)+\".tif\";\n\t\tsave grid_file(file_name, terrain);\n\t}\n\n\taction _init_ {\n\t\t\n\t// A trick to make sure the parameters are expanded and visible when the simulation is launched.\n\t\tbool previous <- gama.pref_experiment_expand_params;\n\t\tgama.pref_experiment_expand_params <- true;\n\t\tcreate simulation;\n\t\tgama.pref_experiment_expand_params <- previous;\n\t}\n\n\tlist<rgb> land_and_sea <- palette(reverse([#darkgreen, #darkgreen, #green, rgb(32, 176, 0), rgb(224, 224, 0), rgb(128, 128, 255), #blue, #blue]));\n\tlist<rgb> field_and_forest <- palette(reverse([#sienna, #olive, #darkgreen, #green, #forestgreen,  #lightgreen]));\n\toutput {\n\t\tlayout #split consoles: false controls: false toolbars: false;\n\t\tdisplay \"Terrain\" type: 3d axes: false camera: #from_up_front {\n\t\t\tmesh terrain color: palette_name = \"Seaside\" ? land_and_sea : field_and_forest triangulation: true;\n\t\t}\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "Create a complete model that demonstrates how to build a simple heatmap based on fields and how to display it. This heatmap records the number of people passed in each area of the city. ",
        "answer": "model BuildingHeatmap\n\nimport \"3D Visualization/models/Building Elevation.gaml\"\n\nglobal {\n\tint size <- 300;\n\tfield instant_heatmap <- field(size, size);\n\tfield history_heatmap <- field(size, size);\n\treflex update {\n\t\tinstant_heatmap[] <- 0 ;\n\t\task people {\n\t\t\tinstant_heatmap[location] <- instant_heatmap[location] + 10;\n\t\t\thistory_heatmap[location] <- history_heatmap[location] + 1;\n\t\t}\n\t}\n}\n\nexperiment \"Show heatmap\" type: gui {\n\toutput synchronized:true{\n\t\tlayout #split;\n\t\t\n\t\tdisplay city_display type: 3d {\n\t\t\tcamera 'default' location: {1318.6512,3.5713,945.6612} target: {431.7016,495.2155,0.0};\n\t\t\tlight #ambient intensity: 180;\n\t\t\tlight #default intensity: 180 direction: {0.5, 0.5, -1};\n\t\t\tevent #mouse_down {ask simulation {do resume;}}\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people refresh: true;\n\t\t}\n\t\tdisplay \"Instant heatmap with palette\" type: 3d axes: false background: #black  {\n\t\t\t// The field is displayed  without 3D rendering, a palettre of warm colors and a smoothness of 2 (meaning two passes of box blur are being done to \"spread\" the values)\n\t\t\tmesh instant_heatmap scale: 0 color: palette([ #black, #black, #orange, #orange, #red, #red, #red]) smooth: 2 ;\n\t\t}\n\t\tdisplay \"History heatmap with gradient\" type: 3d axes: false background: #black camera: #from_up_front {\n\t\t\t// The field is displayed a little bit above the other layers, with a slight 3D rendering, and a smoothness of 1 (meaning one pass of box blur is being done to \"spread\" the values). The colors are provided by a gradient with three stops\n\t\t\tmesh history_heatmap scale: 0.01 color: gradient([#black::0, #cyan::0.5, #red::1]) transparency: 0.2 position: {0, 0, 0.001} smooth:1 ;\n\t\t }\n\t\t\n\n\t}\n\n}",
        "nickname": "julius"
      },
      {
        "question": "I want a code for adding trees to available places in a given parcel, like in tree planting.",
        "answer": "action treePlanting(int no_ttb_planted, parcel destination_parcel){\ngeometry available_space; \n\t\task destination_parcel{\n\t\t\tgeometry sh <- shape;\n\t\t\task parcel_trees {\n\t\t\t\tgeometry occupied_spaces <- circle(self.dbh #cm) translated_to self.location;\n\t\t\t\t sh <- sh - occupied_spaces;\n\t\t\t}\n\t\t\tavailable_space <- sh;\n\t\t}\n\n\n\t\tcreate trees number: no_ttb_planted{\n\t\t\tdbh <- 0.5;\t\n\t\t\tth <- 0.3;\t\n\t\t\tlocation <- any_location_in(available_space);\t\n\t\t\t//location <- any_location_in(myself.my_parcel.shape);//same as above\n\t\t\tmyself.destination_parcel.parcel_trees << self;\t\n\t\t\tgeometry circle_tree <- circle(self.dbh #cm) translated_to self.location;\n\t\t\tavailable_space <- available_space - circle_tree;\n\t\t}\n}\n",
        "nickname": "z"
      },
      {
        "question": "Create an experiment to display a field called \"heatmap\". I wan't smooth color transitions between white and red, depending on the values of the heatmap.",
        "answer": "experiment \"Show heatmap\" type: gui {\n\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n}",
        "nickname": "Louis"
      },
      {
        "question": "Create complete model to show how to use overlay layers in a display.",
        "answer": "model Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model concerning the  use of the simpleBDI plug-in  with emotions. In this model, a technological accident is simulated in one of the buildings of a city center.",
        "answer": "model City_Evacuation\n\nglobal {\n\tfile shapefile_roads <- file(\"../includes/Rouen roads.shp\");\n\tfile shapefile_hazard <- file(\"../includes/Technological hazard.shp\");\n\tfile shapefile_shelters <- file(\"../includes/Escapes.shp\");\n\tgeometry shape <- envelope(shapefile_roads);\n\tgraph road_network;\n\tmap<road,float> current_weights;\n\t\n\tfloat hazard_distance <- 400.0;\n\tfloat catastrophe_distance <- 100.0;\n\tfloat proba_detect_hazard <- 0.2;\n\tfloat proba_detect_other_escape <- 0.01;\n\tfloat other_distance <- 10.0;\n\t\n\tinit {\n\t\tcreate road from: shapefile_roads;\n\t\tcreate hazard from: shapefile_hazard;\n\t\tcreate catastrophe;\n\t\tcreate shelter from: shapefile_shelters;\n\t\t\n\t\t//at the begining of the simulation, we add to the people agent the desire to go to their target.\n\t\tcreate people number: 200{\n\t\t\tlocation <- any_location_in(one_of(road));\n\t\t\tdo add_desire(at_target);\n\t\t\t\n\t\t \t//the agent has also the desire that there is no catastrophe (we set the piority of this desire to 0 as it is a general desire)\n\t\t\tdo add_desire(nonCatastrophe ,0.0);\n\t\t\t\n\t\t\t// we give the agent a random charisma and receptivity (built-in variables linked to the emotions)\n\t\t\tcharisma<-rnd(1.0);\n\t\t\treceptivity<-rnd(1.0);\n\t\t\t\n\t\t\tif(flip(0.9)){\n\t\t\t\tfearful<-true;\n\t\t\t}else{\n\t\t\t\tfearful <- false;\n\t\t\t}\n      \t}\n      \troad_network <- as_edge_graph(road);\n      \tcurrent_weights <- road as_map (each::each.shape.perimeter);\n\t}\n\t\n\treflex update_speeds when: every(10#cycle){\n\t\tcurrent_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n\t\troad_network <- road_network with_weights current_weights;\n\t}\n\t\n\treflex stop_sim when: empty(people) {\n\t\tdo pause;\n\t}\n}\n \nspecies people skills: [moving] control: simple_bdi{\n\tpoint target;\n\tfloat speed <- 30 #km/#h;\n\trgb color <- #blue;\n\tbool escape_mode <- false;\n\tbool fearful;\n\t\n\t//in order to simplify the model we define  4 desires as variables\n\tpredicate at_target <- new_predicate(\"at_target\");\n\tpredicate in_shelter <- new_predicate(\"shelter\");\n\tpredicate has_target <- new_predicate(\"has target\");\n\tpredicate has_shelter <- new_predicate(\"has shelter\");\n\n    //we give them as well 2 beliefs as variables\n\tpredicate catastropheP <- new_predicate(\"catastrophe\");\n\tpredicate nonCatastrophe <- new_predicate(\"catastrophe\",false);\n\t\n\t//at last we define 2 emotion linked to the knowledge of the catastrophe\n\temotion fearConfirmed <- new_emotion(\"fear_confirmed\",catastropheP);\n\temotion fear <- new_emotion(\"fear\",catastropheP);\n\t\n\tbool noTarget<-true;\n\t\n\t//we set this built-in variable to true to use the emotional process\n\tbool use_emotions_architecture <- true;\n\n    //if the agent perceive that their is something that is not normal (a hazard), it has a probability proba_detect_hazard to suppose (add to its unertainty base) that there is a catastrophe occuring\n\tperceive target:hazard in: hazard_distance when: not escape_mode and flip(proba_detect_hazard){\n\t\tfocus id:\"catastrophe\" is_uncertain: true;\n\t\task myself {\n\t\t\tif(fearful){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}else{\n\t\t\t\tcolor<-#green;\n\t\t\t}\n\t\t}\n\t}\n\n\t//if the agent perceive the catastrophe, it adds a belief about it and pass in escape mode\n\tperceive target:catastrophe in:catastrophe_distance{\n\t\tfocus id:\"catastrophe\";\n\t\task myself{\n\t\t\tif(not escape_mode){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//if the agent perceives other people agents in their neighborhood that have fear, it can be contaminate by this emotion\n\tperceive target:people in: other_distance when: not escape_mode {\n\t\temotional_contagion emotion_detected:fearConfirmed when: fearful;\n\t\temotional_contagion emotion_detected:new_emotion(\"fear\") charisma: charisma receptivity:receptivity;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\temotion joy <- nil;\n\t\n\t\n\tperceive target:people in: other_distance{\n\t\temotional_contagion emotion_detected: joy;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\t\n\t//if the agent has a fear confirmed, it has the desire to go to a shelter\n\trule emotion:fearConfirmed remove_intention: at_target new_desire:in_shelter strength:5.0;\n\t\n\t//if the agent has the belief that there is a a catastrophe,  it has the desire to go to a shelter\n\trule belief:new_predicate(\"catastrophe\") remove_intention:at_target new_desire:in_shelter strength:5.0;\n\t\n\trule emotion:new_emotion(\"fear\" ,new_predicate(\"catastrophe\")) new_desire:in_shelter remove_intention:at_target when: fearful strength:5.0;\n\t\n\t//normal move plan\n\tplan normal_move intention: at_target  {\n\t\tif (target = nil) {\n\t\t\ttarget <- any_location_in(one_of(road));\n\t\t} else {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\ttarget <- nil;\n\t\t\t\tnoTarget<-true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//fast evacuation plan in case where the agent has a fear confirmed\n\tplan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 {\n\t\tcolor <- #yellow;\n\t\tspeed <- 60 #km/#h;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\t\n\t\n\t//normal evacuation plan\n\tplan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){\n\t\tcolor <-#darkred;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\taction to_escape_mode {\n\t\tescape_mode <- true;\n\t\tcolor <- #darkred;\n\t\ttarget <- nil;\t\n\t\tnoTarget <- true;\n\t\tdo remove_intention(at_target, true);\n\t}\n\t\n\t\n\taspect default {\n\t\tdraw triangle(30) rotate: heading + 90 color: color;\n\t}\n}\n\nspecies road {\n\tfloat capacity <- 1 + shape.perimeter/50;\n\tint nb_people <- 0 update: length(people at_distance 1);\n\tfloat speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\n\t\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies shelter {\n\taspect default {\n\t\tdraw circle(30) color: rgb(#gamablue,0.8) border: #gamablue depth:10;\n\t}\n}\n\nspecies hazard {\n\taspect default {\n\t\tdraw circle(hazard_distance) color: rgb(#gamaorange,0.3) border:#gamaorange depth:5;\n\t}\n}\n\nspecies catastrophe{\n\tinit{\n\t\tlocation <- first(hazard).location;\n\t}\n\taspect default{\n\t\tdraw circle(catastrophe_distance) color: rgb(#gamared,0.4) border:#gamared depth:10;\n\t}\n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies shelter refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies people;\n\t\t\tspecies catastrophe;\n\t\t\tspecies hazard;\n\t\t}\n\t}\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Create a short and complete Hello World model demonstrating the simple BDI architecture. ",
        "answer": "model HelloWorldBDI\n\nglobal {\n\tinit {\n\t\tcreate bdi_species;\n\t}\n}\n\n//add the simple_bdi architecture to the agents\nspecies bdi_species control: simple_bdi {\n\t\n\t//define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t//at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t//definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}\n\nexperiment HelloWorldBDI type: gui ;",
        "nickname": "Julius"
      },
      {
        "question": "Create a species named bdi_species with the control: simple_bdi.",
        "answer": "species bdi_species control: simple_bdi {\n\t\n\t//define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t//at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t//definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete and simple model to show how the BDI architectures and its tools work (perceive, rule, etc). It's the model of a helicopter that fights fires. The Chopper agent has a general desire to patrol. As it is the only thing he wants at the beginning, it is its initial intention (what it is doing). To patrol, it wanders around (its plan to patrol). When it perceives a fire, it stores this information (it has a new belief about the existence of this fire), and it has a new desire (it wants the fire to be extinct). When it sees a fire, the Patrol intention is put on hold and a new intention is selected (to put out the fire). To achieve this intention, the plan has two steps, i.e. two new (sub)desires: go to the fire and put water on the fire. And so on.",
        "answer": "model Firefighters\n\nglobal {\n\tint displatTextSize <-4;\n\t\n\t//We define the predicates that will be used later.\n\tpredicate patrol_desire <- new_predicate(\"patrol\");\n\tpredicate water_predicate <- new_predicate(\"has water\",true);\n\tpredicate no_water_predicate <- new_predicate(\"has water\", false) ;\n\tstring fireLocation <- \"fireLocation\";\n\t\n\tinit {\n\t\tcreate fireArea number:20;\n\t\tcreate waterArea number:1;\n\t\tcreate firefighter number: 2;\n\t}\n\t\n\treflex stop when: length(fireArea) = 0 {\n\t\tdo pause;\n\t}\n}\n\n\n//give the simple_bdi architecture to the firefighter agents\nspecies firefighter skills: [moving] control: simple_bdi{\t\n\t\n\t//Here are the variables used by a helicopter. \n\trgb color <- rnd_color(150);\n\tfloat waterValue;\n\tgrille maCellule <- one_of(grille);\n\t//Definition of the variables featured in the BDI architecture.\n\tfloat plan_persistence <- 1.0; \n\tfloat intention_persistence <- 1.0;\n\tbool probabilistic_choice <- false;\n\t\n\t//Initialisation of the agent. At the begining, the agent just has the desire to patrol.\n\tinit {\n\t\twaterValue <-2.0;\n\t\tlocation<-maCellule.location;\n\t\tdo add_desire(patrol_desire );\n\t}\n\t\n\t//This perceive is used to update the beliefs concerning the intern variable of the agent (the amount of water it has).\n\tperceive target:self {\n\t\tif(waterValue>0){\n\t\t\tdo add_belief(water_predicate);\n\t\t\tdo remove_belief(no_water_predicate);\n\t\t}\n\t\tif(waterValue<=0){\n\t\t\tdo add_belief(no_water_predicate);\n\t\t\tdo remove_belief(water_predicate);\n\t\t}\n\t}\n\t\n\t//The helicopter perceive the fires at a certain distance. It just record the location of the fire it obsrves. When it sees a fire, it stops it's intention of patroling.\n\tperceive target:fireArea in: 15{ \n\t\tfocus id:\"fireLocation\" var:location strength:10.0; \n\t\task myself{\n\t\t\tdo remove_intention(patrol_desire, true);\n\t\t} \n\t}\n\t\n\t//The rules are used to create a desire from a belief. We can specify the priority of the desire with a statement priority.\n\trule belief: new_predicate(fireLocation) new_desire: get_predicate(get_belief_with_name(fireLocation));\n\trule belief: no_water_predicate new_desire: water_predicate strength: 10.0;\n\t\n\t//The plan to do when the intention is to patrol.\n\tplan patrolling intention:patrol_desire{\n\t\tdo wander amplitude: 30.0 speed: 2.0;\n\t}\n\t \n\t//The plan that is executed when the agent got the intention of extinguish a fire.\n\tplan stopFire intention: new_predicate(fireLocation) priority:5{\n\t\tpoint target_fire <- point(get_predicate(get_current_intention()).values[\"location_value\"] );\n\t\tif(waterValue>0){\n\t\t\tif (self distance_to target_fire <= 1) {\n\t\t\t\tfireArea current_fire <- fireArea first_with (each.location = target_fire);\n\t\t\t\tif (current_fire != nil) {\n\t\t\t\t\t waterValue <- waterValue - 1.0;\n\t\t\t\t\t current_fire.size <-  current_fire.size - 1;\n\t\t\t\t\t if ( current_fire.size <= 0) {\n\t\t\t\t\t\task  current_fire {do die;}\n\t\t\t\t\t\tdo remove_belief(get_predicate(get_current_intention()));\n\t\t\t\t\t\tdo remove_intention(get_predicate(get_current_intention()), true);\n\t\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdo remove_belief(get_predicate(get_current_intention()));\n\t\t\t\t\tdo remove_intention(get_predicate(get_current_intention()), true);\n\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo goto(target: target_fire);\n\t\t\t}\n\t\t} else {\n\t\t\tdo add_subintention(get_current_intention(),water_predicate,true);\n\t\t\tdo current_intention_on_hold();\n\t\t}\n\t}  \n\t\n\t//The plan to take water when the agent get the desire of water.\n    plan gotoTakeWater intention: water_predicate priority:2 {\n    \twaterArea wa <- first(waterArea);\n    \tlist<grille> voisins <-  (grille(location) neighbors_at (1)) + grille(location);\n\t\t\tpath cheminSuivi <-  goto(wa);\n    \tif (self distance_to wa <= 1) {\n    \t\twaterValue <- waterValue + 2.0;\n\t\t}\n    }\n\n\taspect base {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color ;\t\n\t}\n\t\n\taspect bdi {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color wireframe: true;\n\t\tdraw (\"B:\" + length(belief_base) + \":\" + belief_base) color:#black size:displatTextSize; \n\t\tdraw (\"D:\" + length(desire_base) + \":\" + desire_base) color:#black size:displatTextSize at:{location.x,location.y+displatTextSize}; \n\t\tdraw (\"I:\" + length(intention_base) + \":\" + intention_base) color:#black size:displatTextSize at:{location.x,location.y+2*displatTextSize}; \n\t\tdraw (\"curIntention:\" + get_current_intention()) color:#black size:displatTextSize at:{location.x,location.y+3*displatTextSize}; \t\n\t}\n}\n\nspecies fireArea{\n\tfloat size <-1.0;\n\t\n\tinit{\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\t\n\taspect base {\n\t  draw file(\"../includes/Fire.png\") size: 5;\n\t}\n}\n\nspecies waterArea{\n\tinit {\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\taspect base {\n\t  draw square(5) color: #blue border: #black;\t\t\n\t}\n}\n\ngrid grille width: 25 height: 25 neighbors:4 {\n\trgb color <- #green;\n}\n\n\nexperiment fight_fire type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\t\t\t\t\t\n\t\tdisplay view1 { \n\t\t\tgrid grille border: #darkgreen;\n\t\t\tspecies fireArea aspect:base;\n\t\t\tspecies waterArea aspect:base;\n\t\t\tspecies firefighter aspect: bdi;\n\t\t}\n\t}\n\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create a GAML action named treePlanting that takes two parameters: an integer no_ttb_planted representing the number of trees to be planted and a parcel named destination_parcel representing the parcel where the trees will be planted. The action should perform the following:\n1. Within the scope of the destination_parcel, calculate the available space by subtracting the occupied spaces of existing trees in the parcel_trees attribute from the parcel's shape.\n2. Create no_ttb_planted number of trees with attributes dbh set to 0.5 and th set to 0.3.\n3. Place each tree randomly within the calculated available space.\n4. Add each newly created tree to the destination_parcel.parcel_trees list.\n5. Update the available_space by subtracting the space occupied by each newly planted tree (represented by a circle with a radius equal to the tree's dbh).\nNote: This request assumes the existence of agent types trees and parcel with appropriate attributes.",
        "answer": "action treePlanting(int no_ttb_planted, parcel destination_parcel){\ngeometry available_space; \n\t\task destination_parcel{\n\t\t\tgeometry sh <- shape;\n\t\t\task parcel_trees {\n\t\t\t\tgeometry occupied_spaces <- circle(self.dbh #cm) translated_to self.location;\n\t\t\t\t sh <- sh - occupied_spaces;\n\t\t\t}\n\t\t\tavailable_space <- sh;\n\t\t}\n\n\n\t\tcreate trees number: no_ttb_planted{\n\t\t\tdbh <- 0.5;\t\n\t\t\tth <- 0.3;\t\n\t\t\tlocation <- any_location_in(available_space);\t\n\t\t\t//location <- any_location_in(myself.my_parcel.shape);//same as above\n\t\t\tmyself.destination_parcel.parcel_trees << self;\n\t\t\tgeometry circle_tree <- circle(self.dbh #cm) translated_to self.location;\n\t\t\tavailable_space <- available_space - circle_tree;\n\t\t}\n}\n",
        "nickname": "z"
      },
      {
        "question": "Create a complete model which illustrates the use of univariate statistical operators of GAMA.",
        "answer": "model statistic_operators\n\nglobal {\n\tinit tet {\n\t\tlist data <- [1,2,3,4,5,6,7,10,20,100];\n\t\twrite \"data: \" + data;\n\t\twrite \"min: \" + min(data);\n\t\twrite \"max: \" + max(data);\n\t\twrite \"sum: \" + sum(data);\n\t\twrite \"mean: \" + mean(data);\n\t\twrite \"median: \" + median(data);\n\t\twrite \"standard_deviation: \" + standard_deviation(data);\n\t\twrite \"geometric_mean: \" + geometric_mean(data);\n\t\twrite \"harmonic_mean: \" + harmonic_mean(data);\n\t\twrite \"variance: \" + harmonic_mean(data);\n\t\twrite \"mean_deviation: \" + mean_deviation(data);\n\t\twrite \"kurtosis: \" + kurtosis(data);\n\t\twrite \"skewness: \" + skewness(data);\n\t\twrite \"gamma_rnd: \" + gamma_rnd(0.1,1); \n\t\twrite \"gini index: \" + gini([10.0, 1.0, 2.0, 0.0]);\n\t\t\n\t\tlist<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\n\t\twrite \"Dynamic Time Warping: \" + dtw(l1,l2);\n\t\twrite \"Dynamic Time Warping with a radius of 2: \" + dtw(l1,l2,2);\t\n\t}\n}\n\nexperiment test_operators type: gui;",
        "nickname": "Julius"
      },
      {
        "question": "What is the syntax to make a loop in GAMA? ",
        "answer": "loop index from: 0 to: 100 {\n  write index;\n}",
        "nickname": "Arno "
      },
      {
        "question": "Given a list of numbers named data, calculate and write down the standard deviation of this list.",
        "answer": "list data <- [1,2,3,4,5,6,7,10,20,100];\nwrite \"standard_deviation: \" + standard_deviation(data)",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model of pedestrian movement in a simple environment for a big crowd, frontal crossing and perpendicular crossing.",
        "answer": "model pedestrian_simple_environment\n\nglobal {\n\tfloat environment_size <- 50.0 parameter: true;\n\tfloat margin <- 2.0;\n\tint nb_obstacles <- 0 parameter: true;\n\tint nb_people <- 100;\n\tstring scenario <- \"frontal crossing\" among: [\"big crowd\", \"frontal crossing\", \"perpendicular crossing\"] ;\n\t\t\n\tbool display_free_space <- false parameter: true;\n\tbool display_force <- false parameter: true;\n\tbool display_circle_min_dist <- true parameter: true;\n\t\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\tfloat P_proba_detour <- 1.0 parameter: true ;\n\tbool P_avoid_other <- true parameter: true ;\n\tfloat P_obstacle_consideration_distance <- 5.0 parameter: true ;\n\tfloat P_pedestrian_consideration_distance <- 5.0 parameter: true ;\n\tfloat P_tolerance_waypoint <- 0.1 parameter: true;\n\tbool P_use_geometry_waypoint <- true parameter: true;\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"] parameter: true ; \n\t\n\tfloat P_A_pedestrian_SFM_advanced parameter: true <- 25.0 category: \"SFM advanced\" ;\n\tfloat P_A_obstacles_SFM_advanced parameter: true <- 25.0 category: \"SFM advanced\" ;\n\tfloat P_B_pedestrian_SFM_advanced parameter: true <- 0.5 category: \"SFM advanced\" ;\n\tfloat P_B_obstacles_SFM_advanced parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_relaxion_SFM_advanced  parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_gama_SFM_advanced parameter: true <- 0.35 category: \"SFM advanced\" ;\n\tfloat P_lambda_SFM_advanced <- 0.1 parameter: true category: \"SFM advanced\" ;\n\tfloat P_minimal_distance_advanced <- 0.5 parameter: true category: \"SFM advanced\" ;\n\t\n\t\n\tfloat P_n_prime_SFM_simple parameter: true <- 3.0 category: \"SFM simple\" ;\n\tfloat P_n_SFM_simple parameter: true <- 2.0 category: \"SFM simple\" ;\n\tfloat P_lambda_SFM_simple <- 2.0 parameter: true category: \"SFM simple\" ;\n\tfloat P_gama_SFM_simple parameter: true <- 0.35 category: \"SFM simple\" ;\n\tfloat P_relaxion_SFM_simple parameter: true <- 0.54 category: \"SFM simple\" ;\n\tfloat P_A_pedestrian_SFM_simple parameter: true <- 4.5category: \"SFM simple\" ;\n\t\n\tgeometry shape <- square(environment_size);\n\tgeometry free_space <- copy(shape);\n\tgeometry left_space;\n\tgeometry right_space;\n\tgeometry bottom_space; \n\tgeometry top_space;\n\t\n\tfloat step <- 0.1;\n\t\n\tinit {\n\t\tleft_space <- polygon([{0,0}, {0, environment_size}, {environment_size/10, environment_size}, {environment_size/10,0}]);\n\t\tright_space <- polygon([{environment_size,0}, {environment_size, environment_size}, {9 * environment_size/10, environment_size}, {9 * environment_size/10,0}]);\n\t\tbottom_space <- polygon([{0, environment_size}, {0, 9 * environment_size/10}, {environment_size,9*  environment_size/10}, {environment_size, environment_size}]);\t\n\t\ttop_space <- polygon([{0, 0}, {0, environment_size/10}, {environment_size, environment_size/10}, {environment_size, 0.0}]);\t\n\t\t\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tlocation <- any_location_in(square(8*environment_size/10) at_location {environment_size/2, environment_size/2} scaled_by 0.8);\n\t\t\tshape <- sphere(1+rnd(environment_size/50.0));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people number: nb_people {\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <- P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\tuse_geometry_waypoint <- P_use_geometry_waypoint;\n\t\t\ttolerance_waypoint <- P_tolerance_waypoint;\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t}\n\t\t\t\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[obstacle];\n\t\t\tswitch scenario {\n\t\t\t\tmatch \"frontal crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : right_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, even(id) ? right_space : left_space)[1];\n\t\t\t\t} match \"perpendicular crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : bottom_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, (even(id) ? right_space : top_space))[1];\n\t\t\t\t} match \"big crowd\" {\n\t\t\t\t\tlocation <- any_location_in(free_space);\n\t\t\t\t\tcurrent_target <- any_location_in(world.shape.contour);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex end_simulation when: empty(people) {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [pedestrian] schedules: shuffle(people) {\n\trgb color <- rnd_color(255);\n\tfloat speed <- 3 #km/#h;\n\tbool avoid_other <- true;\n\tpoint current_target ;\n\treflex move when: current_target != nil{\n\t\tif (nb_obstacles > 0) {\n\t\t\tdo walk_to target: current_target bounds: free_space;\n\t\t} else {\n\t\t\tdo walk_to target: current_target;\n\t\t}\n\t\tif (self distance_to current_target < 0.5) {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tif (display_circle_min_dist and minimal_distance > 0) {\n\t\t\t\tif not empty(people at_distance minimal_distance) {\n\t\t\t\t\tdraw circle(minimal_distance) color: #red;\n\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif  display_force {\n\t\t\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = obstacle ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nexperiment big_crowd type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"big crowd\", nb_people::500];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n\nexperiment frontal_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"frontal crossing\", nb_people::100];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.5{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\nexperiment perpendicular_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"perpendicular crossing\", nb_people::100];\n\t}\n\t\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.7{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t\tdraw bottom_space color: #yellow border: #black;\n\t\t\t\tdraw top_space color: #magenta border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model to show how to use the pedestrian skill for complex environment. This will use a pedestrian paths from \"Generate Pedestrian path.gaml\".",
        "answer": "model pedestrian_complex_environment\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"../includes/walls.shp\");\n\t\n\tshape_file free_spaces_shape_file <- shape_file(\"../includes/free spaces.shp\");\n\tshape_file open_area_shape_file <- shape_file(\"../includes/open area.shp\");\n\tshape_file pedestrian_paths_shape_file <- shape_file(\"../includes/pedestrian paths.shp\");\n\n\t\n\tgraph network;\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tbool display_free_space <- false parameter: true;\n\tbool display_force <- false parameter: true;\n\tbool display_target <- false parameter: true;\n\tbool display_circle_min_dist <- true parameter: true;\n\t\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\tfloat P_proba_detour <- 0.5 parameter: true ;\n\tbool P_avoid_other <- true parameter: true ;\n\tfloat P_obstacle_consideration_distance <- 3.0 parameter: true ;\n\tfloat P_pedestrian_consideration_distance <- 3.0 parameter: true ;\n\tfloat P_tolerance_target <- 0.1 parameter: true;\n\tbool P_use_geometry_target <- true parameter: true;\n\t\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"] parameter: true ; \n\t\n\tfloat P_A_pedestrian_SFM_advanced parameter: true <- 0.16 category: \"SFM advanced\" ;\n\tfloat P_A_obstacles_SFM_advanced parameter: true <- 1.9 category: \"SFM advanced\" ;\n\tfloat P_B_pedestrian_SFM_advanced parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_B_obstacles_SFM_advanced parameter: true <- 1.0 category: \"SFM advanced\" ;\n\tfloat P_relaxion_SFM_advanced  parameter: true <- 0.5 category: \"SFM advanced\" ;\n\tfloat P_gama_SFM_advanced parameter: true <- 0.35 category: \"SFM advanced\" ;\n\tfloat P_lambda_SFM_advanced <- 0.1 parameter: true category: \"SFM advanced\" ;\n\tfloat P_minimal_distance_advanced <- 0.25 parameter: true category: \"SFM advanced\" ;\n\t\n\tfloat P_n_prime_SFM_simple parameter: true <- 3.0 category: \"SFM simple\" ;\n\tfloat P_n_SFM_simple parameter: true <- 2.0 category: \"SFM simple\" ;\n\tfloat P_lambda_SFM_simple <- 2.0 parameter: true category: \"SFM simple\" ;\n\tfloat P_gama_SFM_simple parameter: true <- 0.35 category: \"SFM simple\" ;\n\tfloat P_relaxion_SFM_simple parameter: true <- 0.54 category: \"SFM simple\" ;\n\tfloat P_A_pedestrian_SFM_simple parameter: true <-4.5category: \"SFM simple\" ;\n\t\n\tfloat step <- 0.1;\n\tint nb_people <- 250;\n\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- first(open_area_shape_file.contents);\n\t\tcreate wall from:wall_shapefile;\n\t\tcreate pedestrian_path from: pedestrian_paths_shape_file {\n\t\t\tlist<geometry> fs <- free_spaces_shape_file overlapping self;\n\t\t\tfree_space <- fs first_with (each covers shape); \n\t\t}\n\t\t\n\n\t\tnetwork <- as_edge_graph(pedestrian_path);\n\t\t\n\t\task pedestrian_path {\n\t\t\tdo build_intersection_areas pedestrian_graph: network;\n\t\t}\n\t\n\t\tcreate people number:nb_people{\n\t\t\tlocation <- any_location_in(one_of(open_area));\n\t\t\tobstacle_consideration_distance <-P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <-P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\t\n\t\t\tuse_geometry_waypoint <- P_use_geometry_target;\n\t\t\ttolerance_waypoint<- P_tolerance_target;\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[wall];\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\t\n\t\t\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\treflex stop when: empty(people) {\n\t\tdo pause;\n\t}\n\t\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\taspect default { \n\t\tdraw shape  color: #gray;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #lightpink border: #black;\n\t\t}\n\t\t\n\t}\n}\n\nspecies wall {\n\tgeometry free_space;\n\tfloat high <- rnd(10.0, 20.0);\n\t\n\taspect demo {\n\t\tdraw shape border: #black depth: high texture: [\"../includes/top.png\",\"../includes/texture5.jpg\"];\n\t}\n\t\n\taspect default {\n\t\tdraw shape + (P_shoulder_length/2.0) color: #gray border: #black;\n\t}\n}\n\nspecies people skills: [pedestrian]{\n\trgb color <- rnd_color(255);\n\tfloat speed <- gauss(5,1.5) #km/#h min: 2 #km/#h;\n\n\treflex move  {\n\t\tif (final_waypoint = nil) {\n\t\t\tdo compute_virtual_path pedestrian_graph:network target: any_location_in(open_area) ;\n\t\t}\n\t\tdo walk ;\n\t}\t\n\t\n\taspect default {\n\t\t\n\t\tif display_circle_min_dist and minimal_distance > 0 {\n\t\t\tdraw circle(minimal_distance).contour color: color;\n\t\t}\n\t\t\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif display_target and current_waypoint != nil {\n\t\t\tdraw line([location,current_waypoint]) color: color;\n\t\t}\n\t\tif  display_force {\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = wall ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n\nexperiment normal_sim type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\t\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: false;\n\t\t\tspecies people;\n\t\t}\n\t}\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model that show how to create pedestrian path and associated free space.",
        "answer": "model generate_pedestrian_path\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"../includes/walls.shp\");\n\t\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\tbool display_free_space <- false parameter: true;\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\t\n\tfloat simplification_dist <- 0.5; //simplification distance for the final geometries\n\t\n\tbool add_points_open_area <- true;//add points to open areas\n \tbool random_densification <- false;//random densification (if true, use random points to fill open areas; if false, use uniform points), \n \tfloat min_dist_open_area <- 0.1;//min distance to considered an area as open area, \n \tfloat density_open_area <- 0.01; //density of points in the open areas (float)\n \tbool clean_network <-  true; \n\tfloat tol_cliping <- 1.0; //tolerance for the cliping in triangulation (float; distance), \n\tfloat tol_triangulation <- 0.1; //tolerance for the triangulation \n\tfloat min_dist_obstacles_filtering <- 0.0;// minimal distance to obstacles to keep a path (float; if 0.0, no filtering), \n\t\n\t\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- copy(shape);\n\t\tcreate wall from:wall_shapefile {\n\t\t\topen_area <- open_area -(shape buffer (P_shoulder_length/2.0));\n\t\t}\n\t\tlist<geometry> generated_lines <- generate_pedestrian_network([],[open_area],add_points_open_area,random_densification,min_dist_open_area,density_open_area,clean_network,tol_cliping,tol_triangulation,min_dist_obstacles_filtering,simplification_dist);\n\t\t\n\t\tcreate pedestrian_path from: generated_lines  {\n\t\t\tdo initialize bounds:[open_area] distance: min(10.0,(wall closest_to self) distance_to self) masked_by: [wall] distance_extremity: 1.0;\n\t\t}\n\t\tsave pedestrian_path to: \"../includes/pedestrian paths.shp\" format:\"shp\";\n\t\tsave open_area to: \"../includes/open area.shp\" format:\"shp\";\n\t\tsave pedestrian_path collect each.free_space to: \"../includes/free spaces.shp\" format:\"shp\";\n\t}\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw shape  color: color;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #cyan border: #black;\n\t\t}\n\t}\n}\n\nspecies wall {\n\taspect default {\n\t\tdraw shape + (P_shoulder_length/2.0) color: #gray border: #black;\n\t}\n}\n\nexperiment normal_sim type: gui {\n\t\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies wall refresh: false;\n\t\t\tgraphics \"open_area\" {\n\t\t\t\tdraw open_area color: #lightpink;\n\t\t\t}\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: false;\n\t\t}\n\t}\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Create complete model which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using the elevation attribute of the contour lines which had been linked to the elevation column of the shapefile.",
        "answer": "model contour_lines_import\n\nglobal {\n\t//the contour lines shapefile\n\tfile shape_file_cl <- file('../includes/contourLines.shp') ;\n\t\n\t//define the size of the world from the countour line shapefile\n\tgeometry shape <- envelope(shape_file_cl);\n\t\n\tinit {\n\t\t//create the contour line agents from the shapefile, and init the elevation for each agent\n\t\tcreate contour_line from: shape_file_cl with: [elevation:: float(read(\"ELEVATION\"))];\n\t\t\n\t\t//triangulate the contour lines\n\t\tlist<geometry> triangles  <- triangulate (list(contour_line));\n\t\t\n\t\t//for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)\n\t\tloop tr over: triangles {\n\t\t\tcreate triangle_ag {\n\t\t\t\tshape <- tr;\n\t\t\t\tloop i from: 0 to: length(shape.points) - 1{ \n\t\t\t\t\tfloat val <- (contour_line closest_to (shape.points at i)).elevation;\n\t\t\t\t\tshape <- shape set_z (i,val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies contour_line {\n\tfloat elevation;\n\taspect default {\n\t\tdraw shape color: #red depth: 30 at: {location.x,location.y, elevation}; \n\t}\n}\nspecies triangle_ag {\n\taspect default {\n\t\tdraw shape color: #grey ; \n\t}\n}\n\n\nexperiment contour_lines_import type: gui {\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tcamera 'default' location: {4341.8834,20215.2668,9585.3894} target: {5500.0,5500.0,0.0};\n\t\t\tspecies triangle_ag refresh: false;\n\t\t\tspecies contour_line refresh: false;\n\t\t}\n\t}\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model which shows how to initialize a grid using a ESRI ASCII file.",
        "answer": "model ascimport\n\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- file('../includes/hab10.asc') ;\n\t\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n//definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data{\n\tinit {\n\t\tcolor<- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);\n\t}\n}\n\nexperiment gridloading type: gui {\n\toutput {\n\t\tdisplay \"As DEM\" type: 3d axes:false{\n\t\t\tgrid cell border: #gray elevation: self.grid_value * 300 ;\n\t\t}\n\t\t\n\t\tdisplay \"As 2D grid\"  type: 2d {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t} \n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Create grid data from ascii file.",
        "answer": "file grid_data <- file('../includes/hab10.asc') ;",
        "nickname": "Julius"
      },
      {
        "question": "Create complete model that initializes a set of geometries from a GEOJSON FIle.",
        "answer": "model geojson_loading   \n\nglobal {\n\tfile geo_file <- geojson_file(\"../includes/countries.geojson\");\n\tgeometry shape <- envelope(geo_file);\n\tinit {\n\t\tcreate countries from: geo_file with: [name::read(\"name\")];\n\t}\n} \n\nspecies countries {\n\trgb color <- rnd_color(255);\n\trgb text_color <- (color.brighter);\n\t\n\tinit {\n\t\tshape <- (simplification(shape,0.01));\n\t}\n\taspect default {\n\t\tdraw shape color: color depth: 10;\n\t\tdraw name font: font(\"Helvetica\", 12 + #zoom, #bold) color: #black at: location + {0,0,12} perspective:false;\n\t}\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay Countries type: 3d{\t\n\t\t\tspecies countries;\t\t\t\n\t\t}\n\t}\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Give me an example GAML function that takes as input a list of laborers and returns the laborer with the highest salary. ",
        "answer": "labour getHWLaborer(list<labour> laborers){\n\t\tlaborers <- reverse(sort_by(laborers, each.salary));\n\t\treturn first(laborers);\n\t}\n",
        "nickname": "z"
      },
      {
        "question": "Create a complete model which shows how to use several grid files to initialize a grid. The elevation file is from a DEM, and the landcover file is from a tif file. ",
        "answer": "model importationraster\n\nglobal {\n\t//the two grid files that we are going to use to initialize the grid\n\tfile dem_file <- file(\"../includes/mnt.asc\");\n\tfile land_cover_file <- file(\"../includes/land-cover.tif\");\n\t\n\t//we use the dem file to initialize the world environment\n\tgeometry shape <- envelope(dem_file);\n\t\n\t//map of colors (key: land_use, value: color)  just uses to visualize the different land_use\n\tmap<int,rgb> colors;\n\t\n\tinit {\n\t\t//we set the value of the land_use variable by the second (index = 1) value stored in the bands attribute \n\t\task cell {\n\t\t\tland_use <- int(bands[1]);\n\t\t}\n\t\t\n\t\t//we define a color per land_use and use it to define the color of the cell\n\t\tlist<int> land_uses <- remove_duplicates(cell collect each.land_use);\n\t\tcolors <- land_uses as_map (each::rnd_color(255));\n\t\task cell {\n\t\t\tcolor <- colors[land_use];\n\t\t}\n\t}\n}\n\n//we define the cell grid from the two grid files: the first file (dem_file) will be used as reference for the definition of the grid number of rows and columns and location\n//the value of the files are stored in the bands built-in list attribute: each value of the list corresponds to the value in the file\n//the value of the first file is also stored in thr grid_value built-in variable\ngrid cell files: [dem_file,land_cover_file] {\n\tint land_use;\n}\n\nexperiment importationraster type: gui {\n\toutput {\n\t\tdisplay map type: 3d axes:false antialias:false{\n\t\t\tgrid cell elevation: true  triangulation: true refresh: false;\t\n\t\t}\n\t}\n}\n",
        "nickname": "Julius"
      },
      {
        "question": "Assuming I've defined a field called \"heatmap\", create an experiment named \"Show heatmap\" with a GUI type. The output section has a layout of type split. Include a display named 'Heatmap' of type 3D with a black background. Use a mesh to visualize the heatmap data. Ensure that the colors transition smoothly as the values increase by defining a fixed color palette with colors ranging from white to red.",
        "answer": "experiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t// The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "Create a complete model to vectorize an image and save result into shapefile.",
        "answer": "model EscapeTrainingEnvironment\n\nglobal {\n\t\n\t/*\n\t * How precise the vectorization is\n\t */\n\tfloat resolution_factor <- 0.2 parameter:true max:1.0;\n\t \n\t/*\n\t * Import the image to vectorize\n\t */\n\timage_file im <- image_file(\"../images/drawing.png\");\n\t\n\t/*\n\t * Get the resolution of the image\n\t */\n\tint res_x <- int(envelope(im).width);\n\tint res_y <- int(envelope(im).height);\n\t\n\t/*\n\t * \n\t * Adapt the underlying grid to vectorize and the shape of the world\n\t * according to image resolution and the ratio of vectorization\n\t * \n\t */\n\tint g_x <- int(res_x * resolution_factor);\n\tint g_y <- int(res_y * resolution_factor);\t\n\tgeometry shape <- rectangle(res_x,res_y);\n\t\n\t/*\n\t * The color and associated species\n\t * WARNING: Model specific\n\t */\n\tmap<rgb,string> color_to_species <- [\n\t\t#brown::string(ground),#blue::string(water),#yellow::string(beach),\n\t\t#green::string(tree),#gray::string(building)\n\t];\n\t\n\tinit {\n\t\tfloat t <- machine_time;\n\t\t\n\t\twrite \"START CREATION OF THE ENVIRONMENT\";\n\t\t\n\t\twrite \"Image resolution : \"+string(res_x)+\" x \"+string(res_y);\n\t\t\n\t\t/*\n\t\t * Manage resolution ratio\n\t\t */\n\t\tfloat factorDiscret_width <- res_y / g_y;\n\t\tfloat factorDiscret_height <- res_x / g_x;\n\t\task cell {\t\t\n\t\t\tcolor <-rgb( (im) at {grid_x * factorDiscret_height,grid_y * factorDiscret_width}) ;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Find the different color in the image\n\t\t */\n\t\tmap<rgb, list<cell>> cells_per_color <- cell group_by each.color;\n\t\t\n\t\twrite \"Found \"+length(cells_per_color)+\" color in the draw\";\n\t\t\n\t\t/*\n\t\t * Loop over all colors and match them with proper species\n\t\t */\n\t\tloop col over: cells_per_color.keys {\n\t\t\tgeometry geom <- union(cells_per_color[col]) + 0.001;\n\t\t\tif (geom != nil) {\n\t\t\t\t\n\t\t\t\twrite \"--------\";\n\t\t\t\trgb best_match;\n\t\t\t\tlist bm <- [255,255,255];\n\t\t\t\tloop cl over:color_to_species.keys {\n\t\t\t\t\tint r <- abs(cl.red-col.red);\n\t\t\t\t\tint g <- abs(cl.green-col.green);\n\t\t\t\t\tint b <- abs(cl.blue-col.blue);\n\t\t\t\t\tif(r+g+b < sum(bm)){\n\t\t\t\t\t\tbest_match <- cl;\n\t\t\t\t\t\tbm <- [r,g,b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twrite \"Detected color image [\"+string(col)+\"] has been associated to [\"+string(best_match)+\"]\";\n\n\t\t\t\t/*\n\t\t\t\t * Create the proper species where color have been detected\n\t\t\t\t */\n\t\t\t\tstring species_name <- color_to_species[best_match];\n\t\t\t\tswitch species_name {\n\t\t\t\t\tmatch string(water) {\n\t\t\t\t\t\tcreate water from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(ground) {\n\t\t\t\t\t\tcreate ground from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(beach) {\n\t\t\t\t\t\tcreate beach from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(tree) {\n\t\t\t\t\t\tcreate tree from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(building) {\n\t\t\t\t\t\tcreate building from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite \"END - TIME ELAPSE: \"+((machine_time-t)/1000)+\"sec\";\n\t\t\n\t\twrite \"EXPORT TO FILES\";\n\t\tsave water to:\"../results/water_body.shp\" ;\n\t\tsave ground to:\"../results/ground.shp\" ;\n\t\tsave beach to:\"../results/beach.shp\" ;\n\t\tsave tree to:\"../results/trees.shp\" ;\n\t\tsave building to:\"../results/building.shp\" ;\n\t\t\n\t}\n\t\n}\n\ngrid cell  width: g_x height: g_y;\n\nspecies water {\n\taspect default {\n\t\tdraw shape color: #navy border: #black;\n\t}\n}\n\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nspecies ground {\n\taspect default {\n\t\tdraw shape color: rgb (128, 64, 3) border: #black;\n\t}\n}\n\nspecies beach {\n\tfloat capacity;\n\taspect default {\n\t\tdraw shape color:#yellow;\n\t}\n}\n\nspecies tree {\n\taspect default {\n\t\tdraw shape border:#black color:#green;\n\t}\n}\n\nexperiment Vectorize type: gui {\n\toutput {\n\t\tdisplay map_vector type:3d axes:false{\n\t\t\tspecies water;\n\t\t\tspecies ground;\n\t\t\tspecies beach;\n\t\t\tspecies tree;\n\t\t\tspecies building;\n\t\t}\n\t\tdisplay image {\n\t\t\timage im;\n\t\t}\n\t}\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create complete model which shows how to import a OSM file in GAMA and use it to create Agents. A filter is used to take only into account the roads and the buildings contained in the file.",
        "answer": "model simpleOSMLoading\n\n\nglobal\n{\n\n//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\", \"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\n\t//OSM file to load\n\tfile<geometry> osmfile;\n\n\t//compute the size of the environment from the envelope of the OSM file\n\tgeometry shape <- envelope(osmfile);\n\tinit\n\t{\n\t//possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\t\tcreate osm_agent from: osmfile with: [highway_str::string(read(\"highway\")), building_str::string(read(\"building\"))];\n\n\t\t//from the created generic agents, creation of the selected agents\n\t\task osm_agent\n\t\t{\n\t\t\tif (length(shape.points) = 1 and highway_str != nil)\n\t\t\t{\n\t\t\t\tcreate node_agent with: [shape::shape, type:: highway_str];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (highway_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate road with: [shape::shape, type:: highway_str];\n\t\t\t\t} else if (building_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate building with: [shape::shape];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//do the generic agent die\n\t\t\tdo die;\n\t\t}\n\n\t}\n\n}\n\nspecies osm_agent\n{\n\tstring highway_str;\n\tstring building_str;\n}\n\nspecies road\n{\n\trgb color <- rnd_color(255);\n\tstring type;\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies node_agent\n{\n\tstring type;\n\taspect default\n\t{\n\t\tdraw square(3) color: # red;\n\t}\n\n}\n\nspecies building\n{\n\taspect default\n\t{\n\t\tdraw shape color: #grey;\n\t}\n\n}\n\nexperiment \"Load OSM\" type: gui\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"../includes/rouen.gz\", filtering));\n\toutput\n\t{\n\t\tdisplay map type: 3d\n\t\t{\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies node_agent refresh: false;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Load OSM from Internet\" type: gui parent: \"Load OSM\"\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"http://download.geofabrik.de/europe/andorra-latest.osm.pbf\", filtering));\n\t\n}",
        "nickname": "Julius"
      },
      {
        "question": "Create a complete model that initializes a grid from a JSON FIle.",
        "answer": "model json_loading   \n\nglobal {\n\tfile JsonFile <- json_file(\"../includes/cityIO.json\");\n    map<string, unknown> c <- JsonFile.contents;\n\n\tinit { \n\t\tlist<map<string, int>> cells <- c[\"grid\"];\n        loop mm over: cells {                 \n            cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n            cell.type <-int(mm[\"type\"]);\n        }\n\t}  \n} \n\ngrid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay cityMatrixView   type: 3d axes:false{\t\n\t\t\tspecies cityMatrix aspect:base;\t\t\t\n\t\t}\n\t}\n}",
        "nickname": "Julius"
      },
      {
        "question": "propose a simple architecture for a model to represent agent that exhibit realistic pedestrian movement",
        "answer": "global {\n\ncreate myagent with:[mytarget::any_location_in(world.shape)];\n\n}\n\nspecies myagent skills:[pedestrian] {\n\npoint mytarget;\n\nreflex move {\ndo walk_to target:mytarget bounds:free_space;\n}\n\ndraw triangle(1) rotate: heading + 90.0;\n\n}\n\nexperiment xp type:gui {\noutput {\ndisplay main {\nspecies myagent;\n}\n}\n}",
        "nickname": "Kevin"
      },
      {
        "question": "Create a model that simulates agents with random data values (from 0 to 50) and identifies those exceeding a specific threshold with a variable called 'threshold'.",
        "answer": "global\n{\n\tint threshold <- 25;\n\tinit\n\t{\n\t\tcreate agentSpecies number: 10;\n\t\tlet agents5 <- agentSpecies where (each.data > threshold);\n\t}\n}\n\nspecies agentSpecies\n{\n\tint data;\n\t\n\tinit\n\t{\n\t\tdata <- rnd(50);\n\t}\n}",
        "nickname": "Guest"
      },
      {
        "question": "Write me an action asking for the user to enter an answer to a question related to her age, and that write back the answer and the age of Gama in the console",
        "answer": "action ask_age {\nmap  result <- user_input_dialog(\"The question\",[enter(\"What is you age?\", 0.0)]);\nwrite \"Your age is \"+result[\"What is you age?\"];\nwrite \"The Gama platform has \"+date(#now).year-2009+\" years old\";\n}",
        "nickname": "Kevin"
      },
      {
        "question": "How can I serialize a given agent to JSON ?",
        "answer": "string serializedAgent <- serialize(agentToBeSerialized);",
        "nickname": "Guest"
      },
      {
        "question": "How can I deserialize an agent from a JSON string ? ",
        "answer": "agentDeserialized deseri <- create agentDeserialized from: serializedString;",
        "nickname": "Guest"
      },
      {
        "question": "give me the minimal starting model to simulate classical opinion dynamic model based on the bounded confidence of agent",
        "answer": "global {\n\nfloat delta <- 0.1;\n\ninit {\ncreate myagent number:100 {\n\topinion <- rnd(1.0)*2-1; \n\tconfidence <- 0.2;\n}\t\n}\n\n}\n\nspecies myagent {\nfloat opinion min:-1 max:1;\nfloat confidence min:-1 max:1;\n\nreflex opinion_diffusion {\n\task any(myagent-self) { \n\t\tif abs(opinion-myself.opinion) < myself.confidence {\n\t\t\tmyself.opinion <- myself.opinion * (1-delta) + opinion * (delta); \n\t\t}\n\t}\n}\n\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay op {\n\t\t\tchart \"opinion_chart\" type:series {\n\t\t\t\tloop a over:myagent { data string(a) value:a.opinion; }\n\t\t\t}\n\t\t}\n\t}\n}",
        "nickname": "Kevin"
      },
      {
        "question": "Generate me a species of grid with theses properties :\n\nEach square can be either alive or dead. This world follows simple rules to decide which cell stay alive and which die in the next turn.\n\n    If a filled cell has fewer than 2 or more than 3 filled neighbors, it die in the next turn\n\n    If an empty square has exactly 3 filled neighbors, it becomes filled in the next turn. \n\nStarting with any arrangement of filled and empty squares, these rules are applied to every square at the same time, creating a new pattern for the next turn.\n\nThe size of the grid is given by two variables : environment_width  and environment_height. Each cell have maximum 8 neighbors. At init, a cell is alive in 20% of the cases.",
        "answer": "grid life_cell width: environment_width height: environment_height neighbors: 8 {\n\tbool new_state;\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\tbool alive <- (rnd(100)) < 80;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\taction evolve {\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\treflex update {\n\t\talive <- new_state;\n\t}\n\n}",
        "nickname": "Guest"
      },
      {
        "question": "Generates a model of social influence, in which 1000 \"people\" agents have an opinion between 0 and 1 and are influenced by other agents - at each stage of the simulation, their opinion moves closer to that of another agent if their opinions are not too far apart. ",
        "answer": "/**\n* Name: BoundedConfidence\n* Model proposed in Deffuant, G., Neau, D., Amblard, F., & Weisbuch, G. (2000). Mixing beliefs among interacting agents. Advances in Complex Systems, 3(01n04), 87-98. \n* Tags: social influence, bounded conficence\n*/\n\nmodel BoundedConfidence\n\nglobal {\n\tfloat mu <- 0.5; //convergence parameter\n\tfloat d <- 0.5; //openness to discussion\n\t\n\tinit {\n\t\tcreate people number: 100;\n\t}\n\t\n}\n\nspecies people {\n\tfloat opinion <- rnd(1.0);\n\t\n\treflex interaction {\n\t\task one_of (people - self) {\n\t\t\tif abs(opinion - myself.opinion) < d {\n\t\t\t\topinion <- opinion + mu * (myself.opinion - opinion);\n\t\t\t\tmyself.opinion <- myself.opinion + mu * (opinion - myself.opinion);\n\t\t\t} \n\t\t}\n\t}\n}\n\nexperiment run type: gui {\n\toutput {\n\t\tdisplay opinion_evolution {\n\t\t\tchart \"opinion evolution\" {\n\t\t\t\tloop p over: people {\n\t\t\t\t\tdata string(int(p)) value: p.opinion;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "nickname": "Guest"
      },
      {
        "question": "Generates a fire propagation model on a grid. At each time step, a cell on fire has a probability of 0.2 of igniting a cell in its neighborhood that has never been on fire, and a cell on fire takes 5 time steps to be no longer on fire. ",
        "answer": "\nmodel fire_spreading\n\nglobal {\n\tint fire_time <- 5;\n\tfloat proba_fire <- 0.2;\n\t\n\tinit {\n\t\task cell(location) {\n\t\t\tdo to_fire;\n\t\t}\n\t}\n}\n\ngrid cell width: 50 height: 50 schedules: cell where each.on_fire{\n\tbool on_fire <- false;\n\tint fire_counter;\n\t\n\taction to_fire {\n\t\ton_fire <- true;\n\t\tcolor <- #red;\n\t\tfire_counter <- fire_time;\n\t}\n\t\n\treflex spread when: on_fire {\n\t\task neighbors where (each.color = #white){\n\t\t\tif flip(proba_fire) {\n\t\t\t\tdo to_fire;\n\t\t\t}\n\t\t}\n\t\tfire_counter <- fire_counter - 1;\n\t\t\n\t}\n\t\n\treflex end_of_fire when: on_fire and fire_counter = 0{\n\t\ton_fire <- false;\n\t\tcolor <- #gray;\n\t}\n}\n\nexperiment fire type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}",
        "nickname": "Guest"
      },
      {
        "question": "Code a model that simulate the international aircraft trafic ",
        "answer": "/**\n* Name: NewModel2\n* Based on the internal empty template. \n* Author: kevinchapuis\n* Tags: \n*/\n\n\nmodel NewModel2\n\nglobal {\n\t\n\tsvg_file planeicon <- svg_file(\"../includes/plane-icon.svg\");\n\n\tshape_file worldmap <- shape_file(\"../includes/worldmap.shp\");\n\tgeometry shape <- envelope(worldmap);\n\t\n\tint maxtripperstep <- 100;\n\n\tinit {\n\t\tcreate country from:worldmap with:[name::get('name')];\n\t\t\n\t\tcsv_file airtripspercapita <- csv_file(\"../includes/air-trips-per-capita.csv\");\n\t\tfloat m <- max(rows_list(matrix(airtripspercapita)) collect (float(last(each))));\n\t\t\n\t\tloop l over:rows_list(matrix(airtripspercapita)) {\n\t\t\tcountry c <- country first_with (first(l)=each.name);\n\t\t\tif c != nil { c.triprob <- float(last(l))/m; }\n\t\t}\n\n\t}\n\n\n}\n\nspecies aircraft skills:[moving]{\n\tfloat speed <- 800#km/#h;\n\tpoint destination;\n\treflex travel {\n\t\tdo goto target:destination;\n\t}\n\t\n\taspect default {\n\t\tdraw planeicon size:100#km color:#black rotate:heading+45;\n\t}\n}\n\nspecies country {\n\tfloat triprob <- 0.01;\n\t\n\treflex when:every(10#mn) {\n\t\tcreate aircraft number:rnd(maxtripperstep*triprob) with:[location::any_location_in(self),destination::any(country-self)];\n\t}\n\t\n\taspect default {\n\t\tdraw shape border:#black;\n\t}\n\t\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies country;\n\t\t\tspecies aircraft;\n\t\t}\n\t}\n}",
        "nickname": "Kevin"
      },
      {
        "question": "Generate a code snippet to load the geotiff file \"/includes/bogota_grid.tif\" and use it to initialize the grid cell.",
        "answer": "global {\n\t//definiton of the file to import\n\tfile grid_data <- grid_file(\"../includes/bogota_grid.tif\");\n\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n\t\n}\n\n//definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;",
        "nickname": "Patrick"
      },
      {
        "question": "How to create a field called \"cells\", from an .asc file.",
        "answer": "grid_file file_to_load <- grid_file(\"includes/example_file.asc\");\nfield cells <- field(file_to_load);",
        "nickname": "Louis"
      },
      {
        "question": "Generate a code snippet to load the \"/includes/hab10.asc\" asc file and to use it to initialize the grid cell.",
        "answer": "\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- file('../includes/hab10.asc') ;\n\t\n\t//computation of the environment size from the arc file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n//definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;",
        "nickname": "Patrick"
      },
      {
        "question": "I have declared a field called \"cells\". Create an experiment called ShowCells of type gui. Add a 3d display called \"Texture\", which displays the field with a jpg texture file. Set the borders to black and enable triangulation.",
        "answer": "experiment Palettes type: gui {\n\toutput synchronized: true {\n\n\t\tdisplay \"Texture \" type: 3d { \n\t\t\tmesh cells texture: file(\"includes/Texture.jpg\") triangulation: true border: #black smooth: true;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}",
        "nickname": "Louis"
      },
      {
        "question": "generate an aspect called obj to display the agent using the my_obj.obj obj file oriented in the direction of the heading of the agent. ",
        "answer": "aspect obj {\n\t\t//we draw an obj file in the aspect apply an initial rotation r0 to give the boat the right orientation and apply a composition of rotation (pitch,roll,yaw) and \n\t\t//the location of a obj file is centroid of the bounding box, so we add with the \"at\" facet a translated along the z axis to place the obj on the ground and not inside\n\t\t//the size represents here the max size of the bounding box\n\t\t//at last, we dynamically apply a rotation to the obj to make it head in direction of the heading of the agents. \n\t\tdraw obj_file(\"my_obj.obj\", -90::{1,0,0}) at: location + {0,0,9} size: 5 rotate: heading + 90;\n\t}\t",
        "nickname": "Patrick"
      },
      {
        "question": "Generate a code snippet to create agents of species my_agents from the \"data.csv\" file reading the \"name\" column to init the name of attribute of the agents and the \"age\" column to init the age attribute of the agents. ",
        "answer": "create my_agent from:csv_file( \"data.csv\",true) with:\n\t\t\t[name::string(get(\"name\")), \n\t\t\t\tage::int(get(\"age\"))\n\t\t\t];\t",
        "nickname": "Patrick"
      },
      {
        "question": "I have defined a field in the global section. Create an experiment named Palettes with two 3d displays called \"Brewer\" and \"Simple gradient\". All the displays use triangulation. The first one uses the set3 from brewers colors. The second one must be a smooth color transition from darkgreen to white. For this latter, the borders of the mesh must be black.\nI want both displays to be displayed at the same time. Moreover, the output must be sychronized with the simulation cycles.",
        "answer": "global {\n\tfield my_field <- field(500,500);\n}\n\nexperiment Palettes type: gui {\n\t// Displays are synchronized with the experiment cycles\n\toutput synchronized: true {\n\t\t// Allows to display all the displays in the same view\n\t\tlayout #split;\n\t\tdisplay \"Brewer\" type: 3d {\n\t\t\tmesh my_field color:(brewer_colors(\"Set3\")) triangulation: true smooth: true;\n\t\t}\n\n\t\tdisplay \"Simple gradient\" type: 3d { \n\t\t\tmesh my_field color: palette([#darkgreen, #darkgreen, #green, #green, #sienna, #sienna, #white]) triangulation: true border: #black ;\n\t\t\t\n\t\t}\n\t}\n\n}",
        "nickname": "Louis"
      },
      {
        "question": "I have defined in the global section the following map: map<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\nI also have an experiment in which I want to add an overlay layer displaying a square for each element in the map color_per_type. Each square must have the color defined in the map, and the name next to them is also the one corresponding to the color.\nThe legend overlay must be at position (5,5) and each square must have a white borde. ",
        "answer": "//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }",
        "nickname": "Louis"
      },
      {
        "question": "I have a model called Overlay. In the global section, give the code of a map whith the following key/value pairs:\n\"water\": #blue\n\"vegetation\": #green\n\"building\": #pink",
        "answer": "model Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}",
        "nickname": "Louis"
      },
      {
        "question": "I have defined a map defined as folows in the global section: map<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\nCode a grid named cell with 10 rows and 10 columns.\nI want each box of the grid to randomly get attributed with one of the colors defined in the color_per_type map.",
        "answer": "grid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}",
        "nickname": "Louis"
      },
      {
        "question": "Create an action named generate to create an realistic random terrain.\nPut the code in the global section.",
        "answer": "global {\n\tfield terrain;\n\n\taction generate {\n\t\t// the generate_terrain operator returns a field where the elevations are between 0 and 1. It can be scaled afterwards.\n\t\tterrain <- generate_terrain(generator_seed, width, height, details, smoothness, scattering);\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "In the global section I have a boolean variable called dark_mode. In the experiment section of my model, add a parameter with the title \"Toggle dark mode\", tracking the value of the dark_mode variable.\nProvide the whole architecture of the model.",
        "answer": "model my_model\n\nglobal {\n\tbool dark_mode <- false;\n\tinit {\n\t\t// Put here the init code\n\t}\n}\n\neperiment my_experiment {\n\tparameter \"Toggle dark mode\" var:dark_mode;\n\touptut {\n\t\t// Put the output code here\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "Create a basic species called Animal represented as a 3d red sphere.\nInstanciate it in a basic experiment.",
        "answer": "species Animal {\n\t\n\t// Add here the logic of the species\n\t\n\t// Define the aspect of the species\n\taspect sphere_aspect {\n\t\tdraw sphere(1.0) color: #red;\n\t}\n}\n\nexperiment my_experiment type: gui {\n\toutput {\n\t\tdisplay basic_display type: 3d {\n\t\t\t// use the sphere_aspect defined in the Animal species\n\t\t\tspecies Animal aspect: sphere_aspect;\n\t\t}\n\t}\n}",
        "nickname": "Louis"
      },
      {
        "question": "I want to create a wizard with 2 fields. The first allows to upload a file from my computer. The other one must be a dropdown menu in which choices are \"circle\" and \"square\".\nName the wizard \"Options\" and add a subtitle \"Choose the simulation options\".\nCreate the wizard in the init statement of the global section.",
        "answer": "global {\n\tinit {\n\t\tmap results <-  wizard(\"My wizard\", eval_finish,\n\t\t\t[ \n\t\t\twizard_page(\"Options\",\"Choose the simulation options\" ,[enter(\"file\" , file), choose(\"shape\", string, \"circle\", [\"circle\", \"square\"])], font(\"Helvetica\", 14 , #bold))\n\t\t\t] \n\t\t);\n\t}\n\t\n\tbool eval_finish(map<string,map> input_map) {\n\t\t return input_map[\"Options\"][\"file\"] != nil;\n\t}\n}",
        "nickname": "Louis"
      }
    ]
  }
}
